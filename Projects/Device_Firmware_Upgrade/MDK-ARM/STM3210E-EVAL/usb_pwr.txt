; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\usb_pwr.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\DFU\inc -I..\..\..\Utilities\STM32_EVAL\Common -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\usb_pwr.crf ..\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;93     *******************************************************************************/
;;;94     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;95     {
;;;96       /* disable all interrupts and force USB reset */
;;;97       _SetCNTR(CNTR_FRES);
000002  4c06              LDR      r4,|L1.28|
000004  2001              MOVS     r0,#1
000006  6020              STR      r0,[r4,#0]
;;;98       /* clear interrupt status register */
;;;99       _SetISTR(0);
000008  1d21              ADDS     r1,r4,#4
00000a  2000              MOVS     r0,#0
00000c  6008              STR      r0,[r1,#0]
;;;100      /* Disable the Pull-Up*/
;;;101      USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;102      /* switch-off device */
;;;103      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  6020              STR      r0,[r4,#0]
;;;104      /* sw variables reset */
;;;105      /* ... */
;;;106    
;;;107      return USB_SUCCESS;
000016  2000              MOVS     r0,#0
;;;108    }
000018  bd10              POP      {r4,pc}
;;;109    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;63     *******************************************************************************/
;;;64     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66       uint16_t wRegVal;
;;;67     
;;;68       /*** cable plugged-in ? ***/
;;;69       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;70     
;;;71       /*** CNTR_PWDN = 0 ***/
;;;72       wRegVal = CNTR_FRES;
;;;73       _SetCNTR(wRegVal);
000008  4806              LDR      r0,|L2.36|
00000a  2101              MOVS     r1,#1                 ;72
00000c  6001              STR      r1,[r0,#0]
;;;74     
;;;75       /*** CNTR_FRES = 0 ***/
;;;76       wInterrupt_Mask = 0;
00000e  2100              MOVS     r1,#0
000010  4a05              LDR      r2,|L2.40|
;;;77       _SetCNTR(wInterrupt_Mask);
000012  6001              STR      r1,[r0,#0]
;;;78       /*** Clear pending interrupts ***/
;;;79       _SetISTR(0);
000014  1d03              ADDS     r3,r0,#4
000016  6019              STR      r1,[r3,#0]
;;;80       /*** Set interrupt mask ***/
;;;81       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000018  f44f51e0          MOV      r1,#0x1c00
00001c  8011              STRH     r1,[r2,#0]
;;;82       _SetCNTR(wInterrupt_Mask);
00001e  6001              STR      r1,[r0,#0]
;;;83       
;;;84       return USB_SUCCESS;
000020  2000              MOVS     r0,#0
;;;85     }
000022  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  |L2.36|
                          DCD      0x40005c40
                  |L2.40|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;258    *******************************************************************************/
;;;259    void Resume(RESUME_STATE eResumeSetVal)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;260    {
;;;261      uint16_t wCNTR;
;;;262    
;;;263      if (eResumeSetVal != RESUME_ESOF)
;;;264        ResumeS.eState = eResumeSetVal;
000004  4c21              LDR      r4,|L3.140|
000006  2807              CMP      r0,#7                 ;263
000008  d000              BEQ      |L3.12|
00000a  7020              STRB     r0,[r4,#0]
                  |L3.12|
;;;265      switch (ResumeS.eState)
00000c  7822              LDRB     r2,[r4,#0]  ; ResumeS
;;;266      {
;;;267        case RESUME_EXTERNAL:
;;;268          if (remotewakeupon ==0)
00000e  4d1f              LDR      r5,|L3.140|
;;;269          {
;;;270            Resume_Init();
;;;271            ResumeS.eState = RESUME_OFF;
000010  2606              MOVS     r6,#6
;;;272          }
;;;273          else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;274          {
;;;275            ResumeS.eState = RESUME_ON;
000012  2105              MOVS     r1,#5
;;;276          }
;;;277          break;
;;;278        case RESUME_INTERNAL:
;;;279          Resume_Init();
;;;280          ResumeS.eState = RESUME_START;
000014  2704              MOVS     r7,#4
;;;281          remotewakeupon = 1;
;;;282          break;
;;;283        case RESUME_LATER:
;;;284          ResumeS.bESOFcnt = 2;
;;;285          ResumeS.eState = RESUME_WAIT;
;;;286          break;
;;;287        case RESUME_WAIT:
;;;288          ResumeS.bESOFcnt--;
;;;289          if (ResumeS.bESOFcnt == 0)
;;;290            ResumeS.eState = RESUME_START;
;;;291          break;
;;;292        case RESUME_START:
;;;293          wCNTR = _GetCNTR();
000016  481e              LDR      r0,|L3.144|
000018  2a06              CMP      r2,#6                 ;265
00001a  d20b              BCS      |L3.52|
00001c  e8dff002          TBB      [pc,r2]               ;265
000020  030c1116          DCB      0x03,0x0c,0x11,0x16
000024  1e27              DCB      0x1e,0x27
000026  6868              LDR      r0,[r5,#4]            ;268  ; remotewakeupon
000028  b110              CBZ      r0,|L3.48|
00002a  7021              STRB     r1,[r4,#0]            ;275
                  |L3.44|
;;;294          wCNTR |= CNTR_RESUME;
;;;295          _SetCNTR(wCNTR);
;;;296          ResumeS.eState = RESUME_ON;
;;;297          ResumeS.bESOFcnt = 10;
;;;298          break;
;;;299        case RESUME_ON:    
;;;300          ResumeS.bESOFcnt--;
;;;301          if (ResumeS.bESOFcnt == 0)
;;;302          {
;;;303            wCNTR = _GetCNTR();
;;;304            wCNTR &= (~CNTR_RESUME);
;;;305            _SetCNTR(wCNTR);
;;;306            ResumeS.eState = RESUME_OFF;
;;;307            remotewakeupon = 0;
;;;308          }
;;;309          break;
;;;310        case RESUME_OFF:
;;;311        case RESUME_ESOF:
;;;312        default:
;;;313          ResumeS.eState = RESUME_OFF;
;;;314          break;
;;;315      }
;;;316    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L3.48|
000030  f7fffffe          BL       Resume_Init
                  |L3.52|
000034  7026              STRB     r6,[r4,#0]            ;313
000036  e7f9              B        |L3.44|
000038  f7fffffe          BL       Resume_Init
00003c  7027              STRB     r7,[r4,#0]            ;280
00003e  2001              MOVS     r0,#1                 ;281
000040  e022              B        |L3.136|
000042  2002              MOVS     r0,#2                 ;284
000044  7060              STRB     r0,[r4,#1]            ;284
000046  2003              MOVS     r0,#3                 ;285
000048  7020              STRB     r0,[r4,#0]            ;285
00004a  e7ef              B        |L3.44|
00004c  7860              LDRB     r0,[r4,#1]            ;288  ; ResumeS
00004e  1e40              SUBS     r0,r0,#1              ;288
000050  7060              STRB     r0,[r4,#1]            ;288
000052  7860              LDRB     r0,[r4,#1]            ;289  ; ResumeS
000054  2800              CMP      r0,#0                 ;289
000056  d1e9              BNE      |L3.44|
000058  7027              STRB     r7,[r4,#0]            ;290
00005a  e7e7              B        |L3.44|
00005c  6802              LDR      r2,[r0,#0]            ;293
00005e  b292              UXTH     r2,r2                 ;293
000060  f0420210          ORR      r2,r2,#0x10           ;294
000064  6002              STR      r2,[r0,#0]            ;295
000066  7021              STRB     r1,[r4,#0]            ;296
000068  200a              MOVS     r0,#0xa               ;297
00006a  7060              STRB     r0,[r4,#1]            ;297
00006c  e7de              B        |L3.44|
00006e  7861              LDRB     r1,[r4,#1]            ;300  ; ResumeS
000070  1e49              SUBS     r1,r1,#1              ;300
000072  7061              STRB     r1,[r4,#1]            ;300
000074  7861              LDRB     r1,[r4,#1]            ;301  ; ResumeS
000076  2900              CMP      r1,#0                 ;301
000078  d1d8              BNE      |L3.44|
00007a  6801              LDR      r1,[r0,#0]            ;303
00007c  b289              UXTH     r1,r1                 ;303
00007e  f0210110          BIC      r1,r1,#0x10           ;304
000082  6001              STR      r1,[r0,#0]            ;305
000084  7026              STRB     r6,[r4,#0]            ;306
000086  2000              MOVS     r0,#0                 ;307
                  |L3.136|
000088  6068              STR      r0,[r5,#4]            ;281  ; remotewakeupon
00008a  e7cf              B        |L3.44|
;;;317    
                          ENDP

                  |L3.140|
                          DCD      ||area_number.11||
                  |L3.144|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;221    *******************************************************************************/
;;;222    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224      uint16_t wCNTR;
;;;225      
;;;226      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;227      /* restart the clocks */
;;;228      /* ...  */
;;;229    
;;;230      /* CNTR_LPMODE = 0 */
;;;231      wCNTR = _GetCNTR();
000002  4c06              LDR      r4,|L4.28|
000004  6820              LDR      r0,[r4,#0]
000006  b280              UXTH     r0,r0
;;;232      wCNTR &= (~CNTR_LPMODE);
000008  f0200004          BIC      r0,r0,#4
;;;233      _SetCNTR(wCNTR);    
00000c  6020              STR      r0,[r4,#0]
;;;234      
;;;235      /* restore full power */
;;;236      /* ... on connected devices */
;;;237      Leave_LowPowerMode();
00000e  f7fffffe          BL       Leave_LowPowerMode
;;;238    
;;;239      /* reset FSUSP bit */
;;;240      _SetCNTR(IMR_MSK);
000012  f44f403f          MOV      r0,#0xbf00
000016  6020              STR      r0,[r4,#0]
;;;241    
;;;242      /* reverse suspend preparation */
;;;243      /* ... */ 
;;;244    
;;;245    }
000018  bd10              POP      {r4,pc}
;;;246    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;116    *******************************************************************************/
;;;117    void Suspend(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;118    {
;;;119    	uint32_t i =0;
;;;120    	uint16_t wCNTR;
;;;121    	uint32_t tmpreg = 0;
;;;122      __IO uint32_t savePWR_CR=0;
;;;123    	/* suspend preparation */
;;;124    	/* ... */
;;;125    	
;;;126    	/*Store CNTR value */
;;;127    	wCNTR = _GetCNTR();  
000002  492a              LDR      r1,|L5.172|
000004  2000              MOVS     r0,#0                 ;119
000006  9000              STR      r0,[sp,#0]
000008  680a              LDR      r2,[r1,#0]
;;;128    
;;;129        /* This a sequence to apply a force RESET to handle a robustness case */
;;;130        
;;;131    	/*Store endpoints registers status */
;;;132        for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
00000a  4b28              LDR      r3,|L5.172|
00000c  4c28              LDR      r4,|L5.176|
00000e  b292              UXTH     r2,r2                 ;127
000010  3b40              SUBS     r3,r3,#0x40
000012  bf00              NOP      
                  |L5.20|
000014  f8535020          LDR      r5,[r3,r0,LSL #2]
000018  b2ad              UXTH     r5,r5
00001a  f8445020          STR      r5,[r4,r0,LSL #2]
00001e  1c40              ADDS     r0,r0,#1
000020  2808              CMP      r0,#8
000022  d3f7              BCC      |L5.20|
;;;133    	
;;;134    	/* unmask RESET flag */
;;;135    	wCNTR|=CNTR_RESETM;
000024  f4426080          ORR      r0,r2,#0x400
;;;136    	_SetCNTR(wCNTR);
000028  6008              STR      r0,[r1,#0]
;;;137    	
;;;138    	/*apply FRES */
;;;139    	wCNTR|=CNTR_FRES;
00002a  f0400001          ORR      r0,r0,#1
;;;140    	_SetCNTR(wCNTR);
00002e  6008              STR      r0,[r1,#0]
;;;141    	
;;;142    	/*clear FRES*/
;;;143    	wCNTR&=~CNTR_FRES;
000030  f0200501          BIC      r5,r0,#1
;;;144    	_SetCNTR(wCNTR);
000034  600d              STR      r5,[r1,#0]
;;;145    	
;;;146    	/*poll for RESET flag in ISTR*/
;;;147    	while((_GetISTR()&ISTR_RESET) == 0);
000036  4a1d              LDR      r2,|L5.172|
000038  1d12              ADDS     r2,r2,#4
                  |L5.58|
00003a  6810              LDR      r0,[r2,#0]
00003c  0540              LSLS     r0,r0,#21
00003e  d5fc              BPL      |L5.58|
;;;148    	
;;;149    	/* clear RESET flag in ISTR */
;;;150    	_SetISTR((uint16_t)CLR_RESET);
000040  f64f30ff          MOV      r0,#0xfbff
000044  6010              STR      r0,[r2,#0]
;;;151    	
;;;152    	/*restore Enpoints*/
;;;153    	for (i=0;i<8;i++)
000046  2000              MOVS     r0,#0
                  |L5.72|
;;;154    	_SetENDPOINT(i, EP[i]);
000048  f8546020          LDR      r6,[r4,r0,LSL #2]
00004c  b2b6              UXTH     r6,r6
00004e  f8436020          STR      r6,[r3,r0,LSL #2]
000052  1c40              ADDS     r0,r0,#1              ;153
000054  2808              CMP      r0,#8                 ;153
000056  d3f7              BCC      |L5.72|
;;;155    	
;;;156    	/* Now it is safe to enter macrocell in suspend mode */
;;;157    	wCNTR |= CNTR_FSUSP;
000058  f0450008          ORR      r0,r5,#8
;;;158    	_SetCNTR(wCNTR);
00005c  6008              STR      r0,[r1,#0]
;;;159    	
;;;160    	/* force low-power mode in the macrocell */
;;;161    	wCNTR = _GetCNTR();
00005e  6808              LDR      r0,[r1,#0]
000060  b280              UXTH     r0,r0
;;;162    	wCNTR |= CNTR_LPMODE;
000062  f0400004          ORR      r0,r0,#4
;;;163    	_SetCNTR(wCNTR);
000066  6008              STR      r0,[r1,#0]
;;;164    	
;;;165    	/*prepare entry in low power mode (STOP mode)*/
;;;166    	/* Select the regulator state in STOP mode*/
;;;167    	savePWR_CR = PWR->CR;
000068  4b12              LDR      r3,|L5.180|
00006a  6818              LDR      r0,[r3,#0]
;;;168    	tmpreg = PWR->CR;
00006c  9000              STR      r0,[sp,#0]
00006e  6818              LDR      r0,[r3,#0]
;;;169    	/* Clear PDDS and LPDS bits */
;;;170    	tmpreg &= ((uint32_t)0xFFFFFFFC);
000070  f0200003          BIC      r0,r0,#3
;;;171    	/* Set LPDS bit according to PWR_Regulator value */
;;;172    	tmpreg |= PWR_Regulator_LowPower;
000074  f0400001          ORR      r0,r0,#1
;;;173    	/* Store the new value */
;;;174    	PWR->CR = tmpreg;
000078  6018              STR      r0,[r3,#0]
;;;175    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;176    #if defined (STM32F30X) || defined (STM32F37X)
;;;177            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;178    #else
;;;179            SCB->SCR |= SCB_SCR_SLEEPDEEP;       
00007a  480f              LDR      r0,|L5.184|
00007c  6804              LDR      r4,[r0,#0]
00007e  f0440404          ORR      r4,r4,#4
000082  6004              STR      r4,[r0,#0]
;;;180    #endif
;;;181    	
;;;182    	/* enter system in STOP mode, only when wakeup flag in not set */
;;;183    	if((_GetISTR()&ISTR_WKUP)==0)
000084  6814              LDR      r4,[r2,#0]
000086  04e4              LSLS     r4,r4,#19
000088  d401              BMI      |L5.142|
;;;184    	{
;;;185    		__WFI();
00008a  bf30              WFI      
;;;186    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;187    #if defined (STM32F30X) || defined (STM32F37X)
;;;188                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
;;;189    #else
;;;190                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); 
00008c  e009              B        |L5.162|
                  |L5.142|
;;;191    #endif
;;;192    	}
;;;193    	else
;;;194    	{
;;;195    		/* Clear Wakeup flag */
;;;196    		_SetISTR(CLR_WKUP);
00008e  f64e74ff          MOV      r4,#0xefff
000092  6014              STR      r4,[r2,#0]
;;;197    		/* clear FSUSP to abort entry in suspend mode  */
;;;198            wCNTR = _GetCNTR();
000094  680a              LDR      r2,[r1,#0]
000096  b292              UXTH     r2,r2
;;;199            wCNTR&=~CNTR_FSUSP;
000098  f0220208          BIC      r2,r2,#8
;;;200            _SetCNTR(wCNTR);
00009c  600a              STR      r2,[r1,#0]
;;;201    		
;;;202    		/*restore sleep mode configuration */ 
;;;203    		/* restore Power regulator config in sleep mode*/
;;;204    		PWR->CR = savePWR_CR;
00009e  9900              LDR      r1,[sp,#0]
0000a0  6019              STR      r1,[r3,#0]
                  |L5.162|
0000a2  6801              LDR      r1,[r0,#0]            ;190
0000a4  f0210104          BIC      r1,r1,#4              ;190
0000a8  6001              STR      r1,[r0,#0]            ;190
;;;205    		
;;;206    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;207    #if defined (STM32F30X) || defined (STM32F37X)		
;;;208                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;209    #else
;;;210                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
;;;211    #endif
;;;212        }
;;;213    }
0000aa  bdf8              POP      {r3-r7,pc}
;;;214    
                          ENDP

                  |L5.172|
                          DCD      0x40005c40
                  |L5.176|
                          DCD      ||.bss||
                  |L5.180|
                          DCD      0x40007000
                  |L5.184|
                          DCD      0xe000ed10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  fSuspendEnabled
000000  01                DCB      0x01

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  ResumeS
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  remotewakeupon
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_pwr.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 144
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
