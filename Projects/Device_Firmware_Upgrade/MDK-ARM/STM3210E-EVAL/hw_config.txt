; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\hw_config.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\DFU\inc -I..\..\..\Utilities\STM32_EVAL\Common -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\hw_config.crf ..\src\hw_config.c]
                          THUMB

                          AREA ||i.DFU_Button_Config||, CODE, READONLY, ALIGN=1

                  DFU_Button_Config PROC
;;;253    *******************************************************************************/
;;;254    void DFU_Button_Config(void)
000000  2100              MOVS     r1,#0
;;;255    {  
;;;256    #if defined (USE_STM32L152_EVAL)
;;;257      /* Configure "DFU enter" button */
;;;258      STM_EVAL_PBInit(Button_UP, Mode_GPIO);  
;;;259    #else  
;;;260      /* Configure "DFU enter" button */
;;;261      //STM_EVAL_PBInit(Button_KEY, Mode_GPIO);
;;;262    	STM_EVAL_PBInit(BUTTON_WAKEUP, Mode_GPIO);
000002  4608              MOV      r0,r1
000004  f7ffbffe          B.W      STM_EVAL_PBInit
;;;263    	
;;;264    #endif /* USE_STM32L152_EVAL */
;;;265    }
;;;266    
                          ENDP


                          AREA ||i.DFU_Button_Read||, CODE, READONLY, ALIGN=1

                  DFU_Button_Read PROC
;;;273    *******************************************************************************/
;;;274    uint8_t DFU_Button_Read (void)
000000  b510              PUSH     {r4,lr}
;;;275    {
;;;276    #if defined (USE_STM32L152_EVAL) 
;;;277      return STM_EVAL_PBGetState(Button_UP); 
;;;278    #elif defined (USE_STM32L152D_EVAL) 
;;;279      return !STM_EVAL_PBGetState(Button_KEY); 
;;;280    #else    
;;;281      return STM_EVAL_PBGetState(BUTTON_WAKEUP);  
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       STM_EVAL_PBGetState
000008  b2c0              UXTB     r0,r0
;;;282    #endif /* USE_STM32L152_EVAL */  
;;;283    }
00000a  bd10              POP      {r4,pc}
;;;284    
                          ENDP


                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;185    *******************************************************************************/
;;;186    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L3.8|
;;;187    {
;;;188      /* Set the device state to suspend */
;;;189      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;190    }
000006  4770              BX       lr
;;;191    
                          ENDP

                  |L3.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;362    *******************************************************************************/
;;;363    void Get_SerialNum(void)
000000  480a              LDR      r0,|L4.44|
;;;364    {
000002  b510              PUSH     {r4,lr}
;;;365      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;366    
;;;367      Device_Serial0 = *(uint32_t*)ID1;
;;;368      Device_Serial1 = *(uint32_t*)ID2;
000004  6801              LDR      r1,[r0,#0]
000006  1d00              ADDS     r0,r0,#4
;;;369      Device_Serial2 = *(uint32_t*)ID3;   
000008  6804              LDR      r4,[r0,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
;;;370    
;;;371      Device_Serial0 += Device_Serial2;
00000e  1808              ADDS     r0,r1,r0
000010  d00b              BEQ      |L4.42|
;;;372    
;;;373      if (Device_Serial0 != 0)
;;;374      {
;;;375        IntToUnicode (Device_Serial0, &DFU_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L4.48|
000016  f7fffffe          BL       IntToUnicode
;;;376        IntToUnicode (Device_Serial1, &DFU_StringSerial[18], 4);
00001a  4905              LDR      r1,|L4.48|
00001c  4620              MOV      r0,r4
00001e  2204              MOVS     r2,#4
000020  e8bd4010          POP      {r4,lr}
000024  3110              ADDS     r1,r1,#0x10
000026  f7ffbffe          B.W      IntToUnicode
                  |L4.42|
;;;377      }
;;;378    }
00002a  bd10              POP      {r4,pc}
;;;379    
                          ENDP

                  |L4.44|
                          DCD      0x1ffff7e8
                  |L4.48|
                          DCD      DFU_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;386    *******************************************************************************/
;;;387    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;388    {
;;;389      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;390      
;;;391      for( idx = 0 ; idx < len ; idx ++)
;;;392      {
;;;393        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;394        {
;;;395          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;396        }
;;;397        else
;;;398        {
;;;399          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L5.50|
00000e  bf00              NOP                            ;393
                  |L5.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;393
000014  d902              BLS      |L5.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;395
00001a  e001              B        |L5.32|
                  |L5.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L5.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;400        }
;;;401        
;;;402        value = value << 4;
;;;403        
;;;404        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;402
00002a  1c5b              ADDS     r3,r3,#1              ;391
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;391
                  |L5.50|
000032  4293              CMP      r3,r2                 ;391
000034  d3ec              BCC      |L5.16|
;;;405      }
;;;406    }
000036  bdf0              POP      {r4-r7,pc}
;;;407    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;198    *******************************************************************************/
;;;199    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L6.20|
;;;200    {
;;;201      DEVICE_INFO *pInfo = &Device_Info;
;;;202    
;;;203      /* Set the device state to the correct state */
;;;204      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;205      {
;;;206        /* Device configured */
;;;207        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L6.24|
000006  b109              CBZ      r1,|L6.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L6.14|
                  |L6.12|
;;;208      }
;;;209      else
;;;210      {
;;;211        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L6.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;212      }
;;;213      /*Enable SystemCoreClock*/
;;;214      SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;215    }
;;;216    
                          ENDP

                  |L6.20|
                          DCD      Device_Info
                  |L6.24|
                          DCD      bDeviceState

                          AREA ||i.Reset_Device||, CODE, READONLY, ALIGN=2

                  Reset_Device PROC
;;;349    *******************************************************************************/
;;;350    void Reset_Device(void)
000000  2000              MOVS     r0,#0
;;;351    {
;;;352      USB_Cable_Config(DISABLE);
000002  f7fffffe          BL       USB_Cable_Config
000006  f3bf8f4f          DSB      
00000a  4805              LDR      r0,|L7.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  4a05              LDR      r2,|L7.36|
000010  f40161e0          AND      r1,r1,#0x700
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
000018  f3bf8f4f          DSB      
                  |L7.28|
00001c  e7fe              B        |L7.28|
;;;353      NVIC_SystemReset();
;;;354    }
;;;355    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0xe000ed0c
                  |L7.36|
                          DCD      0x05fa0004

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;54     *******************************************************************************/
;;;55     void Set_System(void)
000000  b538              PUSH     {r3-r5,lr}
;;;56     {
;;;57     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined (STM32L1XX_MD_PLUS)
;;;58       GPIO_InitTypeDef GPIO_InitStructure;
;;;59     #endif /* STM32L1XX_XD*/
;;;60       
;;;61     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;62       GPIO_InitTypeDef  GPIO_InitStructure;
;;;63     #endif /* USB_USE_EXTERNAL_PULLUP */ 
;;;64       
;;;65       /*!< At this stage the microcontroller clock setting is already configured, 
;;;66            this is done through SystemInit() function which is called from startup
;;;67            file (startup_stm32f10x_xx.s) before to branch to application main.
;;;68            To reconfigure the default setting of SystemInit() function, refer to
;;;69            system_stm32f10x.c file
;;;70          */ 
;;;71       
;;;72     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;73       /* Enable the SYSCFG module clock */
;;;74       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;75     #endif /* STM32L1XX_XD */ 
;;;76        
;;;77     FLASH_Unlock();
000002  f7fffffe          BL       FLASH_Unlock
;;;78       
;;;79     #ifdef USE_STM3210E_EVAL
;;;80       /* Enable the FSMC Clock */
;;;81       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000006  2101              MOVS     r1,#1
000008  020c              LSLS     r4,r1,#8
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;82     #endif /* USE_STM3210E_EVAL */
;;;83     #if defined (USE_STM3210E_EVAL)
;;;84       /* Enable the FSMC Clock */
;;;85       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;86     #endif /* USE_STM3210E_EVAL */
;;;87         
;;;88     #if defined(STM32F37X) || defined(STM32F30X)
;;;89       /* Enable the USB disconnect GPIO clock */
;;;90       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;91     
;;;92      /*Set PA11,12 as IN - USB_DM,DP*/
;;;93       
;;;94       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;95       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;96       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;97       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;98       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;99       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;100      GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;101        
;;;102      /*SET PA11,12 for USB: USB_DM,DP*/
;;;103      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;104      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;105     
;;;106      /* USB_DISCONNECT used as USB pull-up */
;;;107      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;108      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;109      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;110      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;111      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;112      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;113      
;;;114     /*Output low level on USB_Disconnect Pin to enable 1.5k ohm pull-up resistor*/
;;;115      GPIO_WriteBit(USB_DISCONNECT, USB_DISCONNECT_PIN, Bit_RESET);
;;;116    
;;;117    #endif /* STM32F37X && STM32F30X */
;;;118    
;;;119    #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)  && !defined(STM32F37X) && !defined(STM32F30X)
;;;120      /* Enable "DISCONNECT" GPIO clock */
;;;121      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
000018  2101              MOVS     r1,#1
00001a  2008              MOVS     r0,#8
00001c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;122    
;;;123      /* Configure USB pull-up */
;;;124      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
000020  01a0              LSLS     r0,r4,#6
000022  f8ad0000          STRH     r0,[sp,#0]
;;;125      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000026  2003              MOVS     r0,#3
000028  f88d0002          STRB     r0,[sp,#2]
;;;126      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
00002c  2014              MOVS     r0,#0x14
00002e  f88d0003          STRB     r0,[sp,#3]
;;;127      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
000032  4669              MOV      r1,sp
000034  480c              LDR      r0,|L8.104|
000036  f7fffffe          BL       GPIO_Init
;;;128    
;;;129      /* Disable the USB connection till initialization phase end */  
;;;130      USB_Cable_Config(DISABLE);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       USB_Cable_Config
;;;131    #endif /* STM32L1XX_XD */
;;;132    
;;;133    #if defined(USB_USE_EXTERNAL_PULLUP)
;;;134      /* Enable the USB disconnect GPIO clock */
;;;135      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;136    
;;;137      /* USB_DISCONNECT used as USB pull-up */
;;;138      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;139      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;140      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;141      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;142      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;143      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;144    #endif /* USB_USE_EXTERNAL_PULLUP */
;;;145      
;;;146      /* Init the media interface */
;;;147      MAL_Init();
000040  f7fffffe          BL       MAL_Init
;;;148      USB_Cable_Config(ENABLE);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       USB_Cable_Config
;;;149      
;;;150          /* Configure the EXTI line 18 connected internally to the USB IP */
;;;151      EXTI_ClearITPendingBit(EXTI_Line18);
00004a  02a4              LSLS     r4,r4,#10
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;152      EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
000052  4906              LDR      r1,|L8.108|
;;;153      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000054  2008              MOVS     r0,#8
000056  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
000058  7148              STRB     r0,[r1,#5]
;;;154      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00005a  2001              MOVS     r0,#1
00005c  7188              STRB     r0,[r1,#6]
;;;155      EXTI_Init(&EXTI_InitStructure);
00005e  4608              MOV      r0,r1
000060  f7fffffe          BL       EXTI_Init
;;;156    }
000064  bd38              POP      {r3-r5,pc}
;;;157    
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      0x40010c00
                  |L8.108|
                          DCD      ||area_number.15||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;164    *******************************************************************************/
;;;165    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;168      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;169       
;;;170    #else 
;;;171      /* Select USBCLK source */
;;;172      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;173      
;;;174      /* Enable the USB clock */
;;;175      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;176    #endif /* STM32L1XX_MD */
;;;177    }
;;;178    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;223    *******************************************************************************/
;;;224    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;225    {
;;;226    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;227      if (NewState != DISABLE)
;;;228      {
;;;229        STM32L15_USB_CONNECT;
;;;230      }
;;;231      else
;;;232      {
;;;233        STM32L15_USB_DISCONNECT;
;;;234      }  
;;;235    #else 
;;;236      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;237      {
;;;238        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000004  f44f4180          MOV      r1,#0x4000
;;;239      }
;;;240      else
;;;241      {
;;;242        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L10.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L10.16|
000010  f7ffbffe          B.W      GPIO_SetBits
;;;243      }
;;;244    #endif /* STM32L1XX_XD */
;;;245    }
;;;246    
                          ENDP

                  |L10.20|
                          DCD      0x40010c00

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;291    *******************************************************************************/
;;;292    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;293    {
;;;294      NVIC_InitTypeDef NVIC_InitStructure;
;;;295    
;;;296      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;297      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;298      
;;;299    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;300      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;301      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;302      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;303      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;304      NVIC_Init(&NVIC_InitStructure);
;;;305      
;;;306        /* Enable the USB Wake-up interrupt */
;;;307      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
;;;308      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;309      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;310      NVIC_Init(&NVIC_InitStructure);
;;;311      
;;;312    #elif defined(STM32F37X)
;;;313      /* Enable the USB interrupt */
;;;314      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;315      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;316      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;317      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;318      NVIC_Init(&NVIC_InitStructure);
;;;319      
;;;320      /* Enable the USB Wake-up interrupt */
;;;321      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;322      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;323      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;324      NVIC_Init(&NVIC_InitStructure);
;;;325      
;;;326    #else 
;;;327      /* Enable the USB interrupt */
;;;328      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;329      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;330      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;331      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;332      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;333      
;;;334        /* Enable the USB Wake-up interrupt */
;;;335      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;336      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;337      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d5003          STRB     r5,[sp,#3]
;;;338      NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;339      
;;;340    #endif /* STM32L1XX_XD */
;;;341    }
00003c  bd38              POP      {r3-r5,pc}
;;;342    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 144
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
