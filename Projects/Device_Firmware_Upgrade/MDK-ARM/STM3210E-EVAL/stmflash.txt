; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\stmflash.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\stmflash.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\DFU\inc -I..\..\..\Utilities\STM32_EVAL\Common -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\stmflash.crf ..\DFU\src\stmflash.c]
                          THUMB

                          AREA ||i.STMFLASH_Read||, CODE, READONLY, ALIGN=2

                  STMFLASH_Read PROC
;;;97       */
;;;98     void STMFLASH_Read(u32 ReadAddr,u16 *pBuffer,u16 NumToRead)   	
000000  b510              PUSH     {r4,lr}
;;;99     {
;;;100    	u16 i;
;;;101    	for(i=0;i<NumToRead;i++)
000002  2300              MOVS     r3,#0
000004  e006              B        |L1.20|
000006  bf00              NOP                            ;99
                  |L1.8|
000008  f8304b02          LDRH     r4,[r0],#2            ;99
;;;102    	{
;;;103    		pBuffer[i]=STMFLASH_ReadHalfWord(ReadAddr);//读取2个字节.
00000c  f8214013          STRH     r4,[r1,r3,LSL #1]
000010  1c5b              ADDS     r3,r3,#1              ;101
000012  b29b              UXTH     r3,r3                 ;101
                  |L1.20|
000014  4293              CMP      r3,r2                 ;101
000016  d3f7              BCC      |L1.8|
;;;104    		ReadAddr+=2;//偏移2个字节.	
;;;105    	}
;;;106    }
000018  bd10              POP      {r4,pc}
;;;107    
                          ENDP


                          AREA ||i.STMFLASH_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  STMFLASH_ReadHalfWord PROC
;;;8        */
;;;9      u16 STMFLASH_ReadHalfWord(u32 faddr)
000000  8800              LDRH     r0,[r0,#0]
;;;10     {
;;;11     	return *(vu16*)faddr; 
;;;12     }
000002  4770              BX       lr
;;;13     
                          ENDP


                          AREA ||i.STMFLASH_Write||, CODE, READONLY, ALIGN=2

                  STMFLASH_Write PROC
;;;42       */
;;;43     void STMFLASH_Write(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite)	
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;44     {
;;;45     	u32 secpos;	   //扇区地址
;;;46     	u16 secoff;	   //扇区内偏移地址(16位字计算)
;;;47     	u16 secremain; //扇区内剩余地址(16位字计算)	   
;;;48      	u16 i;    
;;;49     	u32 offaddr;   //去掉0X08000000后的地址
;;;50     	if((WriteAddr < FLASH_BASE) || (WriteAddr >= FLASH_BASE + 1024 * FLASH_SIZE))return;//非法地址
000004  f1a06400          SUB      r4,r0,#0x8000000
000008  4615              MOV      r5,r2                 ;44
00000a  468a              MOV      r10,r1                ;44
00000c  4683              MOV      r11,r0                ;44
00000e  f1b45f00          CMP      r4,#0x20000000
000012  d252              BCS      |L3.186|
;;;51     	FLASH_Unlock();						//解锁
000014  f7fffffe          BL       FLASH_Unlock
;;;52     	offaddr = WriteAddr - FLASH_BASE;		//实际偏移地址.
;;;53     	secpos = offaddr / PAGE_SIZE;			//扇区地址  0~127 for STM32F103RBT6
000018  0ae7              LSRS     r7,r4,#11
;;;54     	secoff = (offaddr % PAGE_SIZE) / 2;		//在扇区内的偏移(2个字节为基本单位.)
00001a  f3c40649          UBFX     r6,r4,#1,#10
;;;55     	secremain = PAGE_SIZE / 2 - secoff;		//扇区剩余空间大小   
00001e  f5c66480          RSB      r4,r6,#0x400
;;;56     	if(NumToWrite <= secremain)
000022  42a5              CMP      r5,r4
000024  d800              BHI      |L3.40|
;;;57     		secremain = NumToWrite;//不大于该扇区范围
000026  462c              MOV      r4,r5
                  |L3.40|
;;;58     	while(1) 
;;;59     	{	
;;;60     		STMFLASH_Read(secpos * PAGE_SIZE + FLASH_BASE, STMFLASH_BUF, PAGE_SIZE / 2);//读出整个扇区的内容
000028  f8df9094          LDR      r9,|L3.192|
                  |L3.44|
00002c  f04f6000          MOV      r0,#0x8000000
000030  eb0020c7          ADD      r0,r0,r7,LSL #11
000034  4680              MOV      r8,r0
000036  f44f6280          MOV      r2,#0x400
00003a  4921              LDR      r1,|L3.192|
00003c  f7fffffe          BL       STMFLASH_Read
;;;61     		for(i = 0; i < secremain; i++)//校验数据
000040  2000              MOVS     r0,#0
;;;62     		{
;;;63     			if(STMFLASH_BUF[secoff + i] != 0XFFFF)break;//需要擦除  	  
000042  f64f71ff          MOV      r1,#0xffff
000046  e006              B        |L3.86|
                  |L3.72|
000048  1833              ADDS     r3,r6,r0
00004a  f8392013          LDRH     r2,[r9,r3,LSL #1]
00004e  428a              CMP      r2,r1
000050  d103              BNE      |L3.90|
000052  1c40              ADDS     r0,r0,#1              ;61
000054  b280              UXTH     r0,r0                 ;61
                  |L3.86|
000056  42a0              CMP      r0,r4                 ;61
000058  d3f6              BCC      |L3.72|
                  |L3.90|
;;;64     		}
;;;65     		if(i < secremain)//需要擦除
00005a  42a0              CMP      r0,r4
00005c  d225              BCS      |L3.170|
00005e  4640              MOV      r0,r8
;;;66     		{
;;;67     			FLASH_ErasePage(secpos * PAGE_SIZE + FLASH_BASE);//擦除这个扇区
000060  f7fffffe          BL       FLASH_ErasePage
;;;68     			for(i=0; i < secremain; i++)
000064  2000              MOVS     r0,#0
000066  4649              MOV      r1,r9                 ;60
000068  e007              B        |L3.122|
;;;69     			{
;;;70     				STMFLASH_BUF[i + secoff] = pBuffer[i];	  
00006a  bf00              NOP      
                  |L3.108|
00006c  f83a2010          LDRH     r2,[r10,r0,LSL #1]
000070  1983              ADDS     r3,r0,r6
000072  1c40              ADDS     r0,r0,#1              ;68
000074  f8212013          STRH     r2,[r1,r3,LSL #1]
000078  b280              UXTH     r0,r0                 ;68
                  |L3.122|
00007a  42a0              CMP      r0,r4                 ;68
00007c  d3f6              BCC      |L3.108|
;;;71     			}
;;;72     			STMFLASH_Write_NoCheck(secpos * PAGE_SIZE + FLASH_BASE, STMFLASH_BUF, PAGE_SIZE / 2);//写入整个扇区  
00007e  4910              LDR      r1,|L3.192|
000080  4640              MOV      r0,r8                 ;68
000082  f44f6280          MOV      r2,#0x400
;;;73     		}else 
;;;74     			STMFLASH_Write_NoCheck(WriteAddr, pBuffer, secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
000086  bf00              NOP      
                  |L3.136|
000088  f7fffffe          BL       STMFLASH_Write_NoCheck
;;;75     		if(NumToWrite == secremain)break;//写入结束了
00008c  42a5              CMP      r5,r4
00008e  d010              BEQ      |L3.178|
;;;76     		else//写入未结束
;;;77     		{
;;;78     			secpos++;				//扇区地址增1
;;;79     			secoff = 0;				//偏移位置为0 	 
;;;80     		   	pBuffer += secremain;  	//指针偏移
;;;81     			WriteAddr += secremain;	//写地址偏移	   
;;;82     		   	NumToWrite -= secremain;	//字节(16位)数递减
000090  1b28              SUBS     r0,r5,r4
000092  eb0a0a44          ADD      r10,r10,r4,LSL #1     ;80
000096  44a3              ADD      r11,r11,r4            ;81
000098  1c7f              ADDS     r7,r7,#1              ;78
00009a  2600              MOVS     r6,#0                 ;79
00009c  b285              UXTH     r5,r0
;;;83     			if(NumToWrite > (PAGE_SIZE / 2)) secremain = PAGE_SIZE / 2;//下一个扇区还是写不完
00009e  f44f6480          MOV      r4,#0x400
0000a2  42a5              CMP      r5,r4
0000a4  d8c2              BHI      |L3.44|
;;;84     			else secremain = NumToWrite;//下一个扇区可以写完了
0000a6  462c              MOV      r4,r5
0000a8  e7c0              B        |L3.44|
                  |L3.170|
0000aa  4622              MOV      r2,r4                 ;74
0000ac  4651              MOV      r1,r10                ;74
0000ae  4658              MOV      r0,r11                ;74
0000b0  e7ea              B        |L3.136|
                  |L3.178|
;;;85     		}	 
;;;86     	};	
;;;87     	FLASH_Lock();//上锁
0000b2  e8bd5ff0          POP      {r4-r12,lr}
0000b6  f7ffbffe          B.W      FLASH_Lock
                  |L3.186|
;;;88     }
0000ba  e8bd9ff0          POP      {r4-r12,pc}
;;;89     
                          ENDP

0000be  0000              DCW      0x0000
                  |L3.192|
                          DCD      ||.bss||

                          AREA ||i.STMFLASH_Write_NoCheck||, CODE, READONLY, ALIGN=2

                  STMFLASH_Write_NoCheck PROC
;;;22       */
;;;23     static void STMFLASH_Write_NoCheck(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;24     { 			 		 
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;25     	u16 i;
;;;26     	for(i=0;i<NumToWrite;i++)
00000a  2400              MOVS     r4,#0
00000c  e008              B        |L4.32|
;;;27     	{
;;;28     		FLASH_ProgramHalfWord(WriteAddr,pBuffer[i]);
00000e  bf00              NOP      
                  |L4.16|
000010  f8371014          LDRH     r1,[r7,r4,LSL #1]
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       FLASH_ProgramHalfWord
;;;29     	    WriteAddr+=2;//add addr 2.
00001a  1cad              ADDS     r5,r5,#2
00001c  1c64              ADDS     r4,r4,#1              ;26
00001e  b2a4              UXTH     r4,r4                 ;26
                  |L4.32|
000020  42b4              CMP      r4,r6                 ;26
000022  d3f5              BCC      |L4.16|
;;;30     	}  
;;;31     } 
000024  e8bd81f0          POP      {r4-r8,pc}
;;;32     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  STMFLASH_BUF
                          %        2048

;*** Start embedded assembler ***

#line 1 "..\\DFU\\src\\stmflash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_stmflash_c_69bb3012____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_stmflash_c_69bb3012____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_stmflash_c_69bb3012____REVSH|
#line 144
|__asm___10_stmflash_c_69bb3012____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
