; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\stm32f10x_flash.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -I..\DFU\inc -I..\..\..\Utilities\STM32_EVAL\Common -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\stm32f10x_flash.crf ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1443     */
;;;1444   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1445   {
;;;1446   #ifdef STM32F10X_XL
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1449   
;;;1450     if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1451     {
;;;1452       /* Clear the flags */
;;;1453       FLASH->SR2 = FLASH_FLAG;
;;;1454     }
;;;1455     else
;;;1456     {
;;;1457       /* Clear the flags */
;;;1458       FLASH->SR = FLASH_FLAG;
;;;1459     }  
;;;1460   
;;;1461   #else
;;;1462     /* Check the parameters */
;;;1463     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1464     
;;;1465     /* Clear the flags */
;;;1466     FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;1467   #endif /* STM32F10X_XL */
;;;1468   }
000004  4770              BX       lr
;;;1469   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;975      */
;;;976    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;977    {
;;;978      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
;;;979      
;;;980      FLASH_Status status = FLASH_COMPLETE;
;;;981      
;;;982      /* Check the parameters */
;;;983      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;984      
;;;985      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000004  43c0              MVNS     r0,r0
;;;986      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000006  b2c7              UXTB     r7,r0
;;;987      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000008  f3c02607          UBFX     r6,r0,#8,#8
;;;988      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00000c  f3c04507          UBFX     r5,r0,#16,#8
;;;989      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
000010  0e04              LSRS     r4,r0,#24
;;;990      
;;;991      /* Wait for last operation to be completed */
;;;992      status = FLASH_WaitForLastOperation(ProgramTimeout);
000012  f44f5900          MOV      r9,#0x2000
000016  4648              MOV      r0,r9
000018  f7fffffe          BL       FLASH_WaitForLastOperation
;;;993      
;;;994      if(status == FLASH_COMPLETE)
00001c  2804              CMP      r0,#4
00001e  d13b              BNE      |L2.152|
;;;995      {
;;;996        /* Authorizes the small information block programming */
;;;997        FLASH->OPTKEYR = FLASH_KEY1;
000020  f8df807c          LDR      r8,|L2.160|
000024  4a1d              LDR      r2,|L2.156|
000026  f8c82008          STR      r2,[r8,#8]
;;;998        FLASH->OPTKEYR = FLASH_KEY2;
00002a  4a1e              LDR      r2,|L2.164|
00002c  f8c82008          STR      r2,[r8,#8]
;;;999        FLASH->CR |= CR_OPTPG_Set;
000030  f8d82010          LDR      r2,[r8,#0x10]
000034  f0420210          ORR      r2,r2,#0x10
000038  f8c82010          STR      r2,[r8,#0x10]
;;;1000       if(WRP0_Data != 0xFF)
00003c  2fff              CMP      r7,#0xff
00003e  d006              BEQ      |L2.78|
;;;1001       {
;;;1002         OB->WRP0 = WRP0_Data;
000040  4819              LDR      r0,|L2.168|
000042  8007              STRH     r7,[r0,#0]
;;;1003         
;;;1004         /* Wait for last operation to be completed */
;;;1005         status = FLASH_WaitForLastOperation(ProgramTimeout);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1006       }
;;;1007       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
00004a  2804              CMP      r0,#4
00004c  d11b              BNE      |L2.134|
                  |L2.78|
00004e  2eff              CMP      r6,#0xff
000050  d007              BEQ      |L2.98|
;;;1008       {
;;;1009         OB->WRP1 = WRP1_Data;
000052  4815              LDR      r0,|L2.168|
000054  1c80              ADDS     r0,r0,#2
000056  8006              STRH     r6,[r0,#0]
;;;1010         
;;;1011         /* Wait for last operation to be completed */
;;;1012         status = FLASH_WaitForLastOperation(ProgramTimeout);
000058  4648              MOV      r0,r9
00005a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1013       }
;;;1014       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
00005e  2804              CMP      r0,#4
000060  d111              BNE      |L2.134|
                  |L2.98|
000062  2dff              CMP      r5,#0xff
000064  d007              BEQ      |L2.118|
;;;1015       {
;;;1016         OB->WRP2 = WRP2_Data;
000066  4810              LDR      r0,|L2.168|
000068  1d00              ADDS     r0,r0,#4
00006a  8005              STRH     r5,[r0,#0]
;;;1017         
;;;1018         /* Wait for last operation to be completed */
;;;1019         status = FLASH_WaitForLastOperation(ProgramTimeout);
00006c  4648              MOV      r0,r9
00006e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1020       }
;;;1021       
;;;1022       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000072  2804              CMP      r0,#4
000074  d107              BNE      |L2.134|
                  |L2.118|
000076  2cff              CMP      r4,#0xff
000078  d007              BEQ      |L2.138|
;;;1023       {
;;;1024         OB->WRP3 = WRP3_Data;
00007a  480b              LDR      r0,|L2.168|
00007c  1d80              ADDS     r0,r0,#6
00007e  8004              STRH     r4,[r0,#0]
;;;1025        
;;;1026         /* Wait for last operation to be completed */
;;;1027         status = FLASH_WaitForLastOperation(ProgramTimeout);
000080  4648              MOV      r0,r9
000082  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L2.134|
;;;1028       }
;;;1029             
;;;1030       if(status != FLASH_TIMEOUT)
000086  2805              CMP      r0,#5
000088  d006              BEQ      |L2.152|
                  |L2.138|
;;;1031       {
;;;1032         /* if the program operation is completed, disable the OPTPG Bit */
;;;1033         FLASH->CR &= CR_OPTPG_Reset;
00008a  f8d82010          LDR      r2,[r8,#0x10]
00008e  f64173ef          MOV      r3,#0x1fef
000092  401a              ANDS     r2,r2,r3
000094  f8c82010          STR      r2,[r8,#0x10]
                  |L2.152|
;;;1034       }
;;;1035     } 
;;;1036     /* Return the write protection operation Status */
;;;1037     return status;       
;;;1038   }
000098  e8bd83f0          POP      {r4-r9,pc}
;;;1039   
                          ENDP

                  |L2.156|
                          DCD      0x45670123
                  |L2.160|
                          DCD      0x40022000
                  |L2.164|
                          DCD      0xcdef89ab
                  |L2.168|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;555      */
;;;556    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b530              PUSH     {r4,r5,lr}
;;;557    {
;;;558      FLASH_Status status = FLASH_COMPLETE;
;;;559      /* Wait for last operation to be completed */
;;;560      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000002  f44f2530          MOV      r5,#0xb0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
;;;561      
;;;562      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d110              BNE      |L3.50|
;;;563      {
;;;564        /* if the previous operation is completed, proceed to erase all pages */
;;;565         FLASH->CR |= CR_MER_Set;
000010  4c08              LDR      r4,|L3.52|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;566         FLASH->CR |= CR_STRT_Set;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;567        
;;;568        /* Wait for last operation to be completed */
;;;569        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       FLASH_WaitForLastBank1Operation
;;;570        
;;;571        /* Disable the MER Bit */
;;;572        FLASH->CR &= CR_MER_Reset;
000028  6921              LDR      r1,[r4,#0x10]
00002a  f64172fb          MOV      r2,#0x1ffb
00002e  4011              ANDS     r1,r1,r2
000030  6121              STR      r1,[r4,#0x10]
                  |L3.50|
;;;573      }    
;;;574      /* Return the Erase Status */
;;;575      return status;
;;;576    }
000032  bd30              POP      {r4,r5,pc}
;;;577    
                          ENDP

                  |L3.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;492      */
;;;493    FLASH_Status FLASH_EraseAllPages(void)
000000  b530              PUSH     {r4,r5,lr}
;;;494    {
;;;495      FLASH_Status status = FLASH_COMPLETE;
;;;496    
;;;497    #ifdef STM32F10X_XL
;;;498      /* Wait for last operation to be completed */
;;;499      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;500      
;;;501      if(status == FLASH_COMPLETE)
;;;502      {
;;;503        /* if the previous operation is completed, proceed to erase all pages */
;;;504         FLASH->CR |= CR_MER_Set;
;;;505         FLASH->CR |= CR_STRT_Set;
;;;506        
;;;507        /* Wait for last operation to be completed */
;;;508        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;509        
;;;510        /* Disable the MER Bit */
;;;511        FLASH->CR &= CR_MER_Reset;
;;;512      }    
;;;513      if(status == FLASH_COMPLETE)
;;;514      {
;;;515        /* if the previous operation is completed, proceed to erase all pages */
;;;516         FLASH->CR2 |= CR_MER_Set;
;;;517         FLASH->CR2 |= CR_STRT_Set;
;;;518        
;;;519        /* Wait for last operation to be completed */
;;;520        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;521        
;;;522        /* Disable the MER Bit */
;;;523        FLASH->CR2 &= CR_MER_Reset;
;;;524      }
;;;525    #else
;;;526      /* Wait for last operation to be completed */
;;;527      status = FLASH_WaitForLastOperation(EraseTimeout);
000002  f44f2530          MOV      r5,#0xb0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;528      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d110              BNE      |L4.50|
;;;529      {
;;;530        /* if the previous operation is completed, proceed to erase all pages */
;;;531         FLASH->CR |= CR_MER_Set;
000010  4c08              LDR      r4,|L4.52|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;532         FLASH->CR |= CR_STRT_Set;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;533        
;;;534        /* Wait for last operation to be completed */
;;;535        status = FLASH_WaitForLastOperation(EraseTimeout);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       FLASH_WaitForLastOperation
;;;536    
;;;537        /* Disable the MER Bit */
;;;538        FLASH->CR &= CR_MER_Reset;
000028  6921              LDR      r1,[r4,#0x10]
00002a  f64172fb          MOV      r2,#0x1ffb
00002e  4011              ANDS     r1,r1,r2
000030  6121              STR      r1,[r4,#0x10]
                  |L4.50|
;;;539      }
;;;540    #endif /* STM32F10X_XL */
;;;541    
;;;542      /* Return the Erase Status */
;;;543      return status;
;;;544    }
000032  bd30              POP      {r4,r5,pc}
;;;545    
                          ENDP

                  |L4.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;616      */
;;;617    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b570              PUSH     {r4-r6,lr}
;;;618    {
;;;619      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;620    
;;;621      FLASH_Status status = FLASH_COMPLETE;
;;;622    
;;;623      /* Get the actual read protection Option Byte value */ 
;;;624      if(FLASH_GetReadOutProtectionStatus() != RESET)
000004  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
000008  b100              CBZ      r0,|L5.12|
;;;625      {
;;;626        rdptmp = 0x00;  
00000a  2500              MOVS     r5,#0
                  |L5.12|
;;;627      }
;;;628    
;;;629      /* Wait for last operation to be completed */
;;;630      status = FLASH_WaitForLastOperation(EraseTimeout);
00000c  f44f2630          MOV      r6,#0xb0000
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       FLASH_WaitForLastOperation
;;;631      if(status == FLASH_COMPLETE)
000016  2804              CMP      r0,#4
000018  d127              BNE      |L5.106|
;;;632      {
;;;633        /* Authorize the small information block programming */
;;;634        FLASH->OPTKEYR = FLASH_KEY1;
00001a  4c15              LDR      r4,|L5.112|
00001c  4813              LDR      r0,|L5.108|
00001e  60a0              STR      r0,[r4,#8]
;;;635        FLASH->OPTKEYR = FLASH_KEY2;
000020  4814              LDR      r0,|L5.116|
000022  60a0              STR      r0,[r4,#8]
;;;636        
;;;637        /* if the previous operation is completed, proceed to erase the option bytes */
;;;638        FLASH->CR |= CR_OPTER_Set;
000024  6920              LDR      r0,[r4,#0x10]
000026  f0400020          ORR      r0,r0,#0x20
00002a  6120              STR      r0,[r4,#0x10]
;;;639        FLASH->CR |= CR_STRT_Set;
00002c  6920              LDR      r0,[r4,#0x10]
00002e  f0400040          ORR      r0,r0,#0x40
000032  6120              STR      r0,[r4,#0x10]
;;;640        /* Wait for last operation to be completed */
;;;641        status = FLASH_WaitForLastOperation(EraseTimeout);
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       FLASH_WaitForLastOperation
;;;642        
;;;643        if(status == FLASH_COMPLETE)
;;;644        {
;;;645          /* if the erase operation is completed, disable the OPTER Bit */
;;;646          FLASH->CR &= CR_OPTER_Reset;
;;;647           
;;;648          /* Enable the Option Bytes Programming operation */
;;;649          FLASH->CR |= CR_OPTPG_Set;
;;;650          /* Restore the last read protection Option Byte value */
;;;651          OB->RDP = (uint16_t)rdptmp; 
;;;652          /* Wait for last operation to be completed */
;;;653          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;654     
;;;655          if(status != FLASH_TIMEOUT)
;;;656          {
;;;657            /* if the program operation is completed, disable the OPTPG Bit */
;;;658            FLASH->CR &= CR_OPTPG_Reset;
00003a  f64176ef          MOV      r6,#0x1fef
00003e  2804              CMP      r0,#4                 ;643
000040  d10e              BNE      |L5.96|
000042  6920              LDR      r0,[r4,#0x10]         ;646
000044  f64171df          MOV      r1,#0x1fdf            ;646
000048  4008              ANDS     r0,r0,r1              ;646
00004a  6120              STR      r0,[r4,#0x10]         ;646
00004c  6920              LDR      r0,[r4,#0x10]         ;649
00004e  f0400010          ORR      r0,r0,#0x10           ;649
000052  6120              STR      r0,[r4,#0x10]         ;649
000054  4808              LDR      r0,|L5.120|
000056  8005              STRH     r5,[r0,#0]            ;651
000058  f44f5000          MOV      r0,#0x2000            ;653
00005c  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L5.96|
;;;659          }
;;;660        }
;;;661        else
;;;662        {
;;;663          if (status != FLASH_TIMEOUT)
000060  2805              CMP      r0,#5
000062  d002              BEQ      |L5.106|
000064  6921              LDR      r1,[r4,#0x10]         ;658
000066  4031              ANDS     r1,r1,r6              ;658
000068  6121              STR      r1,[r4,#0x10]         ;658
                  |L5.106|
;;;664          {
;;;665            /* Disable the OPTPG Bit */
;;;666            FLASH->CR &= CR_OPTPG_Reset;
;;;667          }
;;;668        }  
;;;669      }
;;;670      /* Return the erase status */
;;;671      return status;
;;;672    }
00006a  bd70              POP      {r4-r6,pc}
;;;673    
                          ENDP

                  |L5.108|
                          DCD      0x45670123
                  |L5.112|
                          DCD      0x40022000
                  |L5.116|
                          DCD      0xcdef89ab
                  |L5.120|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;419      */
;;;420    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;421    {
000002  4605              MOV      r5,r0
;;;422      FLASH_Status status = FLASH_COMPLETE;
;;;423      /* Check the parameters */
;;;424      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;425    
;;;426    #ifdef STM32F10X_XL
;;;427      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
;;;428      {
;;;429        /* Wait for last operation to be completed */
;;;430        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;431        if(status == FLASH_COMPLETE)
;;;432        { 
;;;433          /* if the previous operation is completed, proceed to erase the page */
;;;434          FLASH->CR|= CR_PER_Set;
;;;435          FLASH->AR = Page_Address; 
;;;436          FLASH->CR|= CR_STRT_Set;
;;;437        
;;;438          /* Wait for last operation to be completed */
;;;439          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;440    
;;;441          /* Disable the PER Bit */
;;;442          FLASH->CR &= CR_PER_Reset;
;;;443        }
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Wait for last operation to be completed */
;;;448        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;449        if(status == FLASH_COMPLETE)
;;;450        { 
;;;451          /* if the previous operation is completed, proceed to erase the page */
;;;452          FLASH->CR2|= CR_PER_Set;
;;;453          FLASH->AR2 = Page_Address; 
;;;454          FLASH->CR2|= CR_STRT_Set;
;;;455        
;;;456          /* Wait for last operation to be completed */
;;;457          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;458          
;;;459          /* Disable the PER Bit */
;;;460          FLASH->CR2 &= CR_PER_Reset;
;;;461        }
;;;462      }
;;;463    #else
;;;464      /* Wait for last operation to be completed */
;;;465      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2630          MOV      r6,#0xb0000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;466      
;;;467      if(status == FLASH_COMPLETE)
00000e  2804              CMP      r0,#4
000010  d111              BNE      |L6.54|
;;;468      { 
;;;469        /* if the previous operation is completed, proceed to erase the page */
;;;470        FLASH->CR|= CR_PER_Set;
000012  4c09              LDR      r4,|L6.56|
000014  6920              LDR      r0,[r4,#0x10]
000016  f0400002          ORR      r0,r0,#2
00001a  6120              STR      r0,[r4,#0x10]
;;;471        FLASH->AR = Page_Address; 
00001c  6165              STR      r5,[r4,#0x14]
;;;472        FLASH->CR|= CR_STRT_Set;
00001e  6920              LDR      r0,[r4,#0x10]
000020  f0400040          ORR      r0,r0,#0x40
000024  6120              STR      r0,[r4,#0x10]
;;;473        
;;;474        /* Wait for last operation to be completed */
;;;475        status = FLASH_WaitForLastOperation(EraseTimeout);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       FLASH_WaitForLastOperation
;;;476        
;;;477        /* Disable the PER Bit */
;;;478        FLASH->CR &= CR_PER_Reset;
00002c  6921              LDR      r1,[r4,#0x10]
00002e  f64172fd          MOV      r2,#0x1ffd
000032  4011              ANDS     r1,r1,r2
000034  6121              STR      r1,[r4,#0x10]
                  |L6.54|
;;;479      }
;;;480    #endif /* STM32F10X_XL */
;;;481    
;;;482      /* Return the Erase Status */
;;;483      return status;
;;;484    }
000036  bd70              POP      {r4-r6,pc}
;;;485    
                          ENDP

                  |L6.56|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1515     */
;;;1516   FLASH_Status FLASH_GetBank1Status(void)
000000  4908              LDR      r1,|L7.36|
;;;1517   {
;;;1518     FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;1519     
;;;1520     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L7.14|
;;;1521     {
;;;1522       flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;1523     }
;;;1524     else 
;;;1525     {  
;;;1526       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
;;;1527       { 
;;;1528         flashstatus = FLASH_ERROR_PG;
;;;1529       }
;;;1530       else 
;;;1531       {
;;;1532         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
;;;1533         {
;;;1534           flashstatus = FLASH_ERROR_WRP;
;;;1535         }
;;;1536         else
;;;1537         {
;;;1538           flashstatus = FLASH_COMPLETE;
;;;1539         }
;;;1540       }
;;;1541     }
;;;1542     /* Return the Flash Status */
;;;1543     return flashstatus;
;;;1544   }
00000c  4770              BX       lr
                  |L7.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;1526
000010  0752              LSLS     r2,r2,#29             ;1526
000012  d501              BPL      |L7.24|
000014  2002              MOVS     r0,#2                 ;1528
                  |L7.22|
000016  4770              BX       lr
                  |L7.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;1532
00001a  06c9              LSLS     r1,r1,#27             ;1532
00001c  d5fb              BPL      |L7.22|
00001e  2003              MOVS     r0,#3                 ;1534
000020  4770              BX       lr
;;;1545   
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1357     */
;;;1358   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;1359   {
;;;1360     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1361   
;;;1362   #ifdef STM32F10X_XL
;;;1363     /* Check the parameters */
;;;1364     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1365     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1366     {
;;;1367       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1368       {
;;;1369         bitstatus = SET;
;;;1370       }
;;;1371       else
;;;1372       {
;;;1373         bitstatus = RESET;
;;;1374       }
;;;1375     }
;;;1376     else
;;;1377     {
;;;1378       if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1379       {
;;;1380         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
;;;1381         {
;;;1382           bitstatus = SET;
;;;1383         }
;;;1384         else
;;;1385         {
;;;1386           bitstatus = RESET;
;;;1387         }
;;;1388       }
;;;1389       else
;;;1390       {
;;;1391         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1392         {
;;;1393           bitstatus = SET;
;;;1394         }
;;;1395         else
;;;1396         {
;;;1397           bitstatus = RESET;
;;;1398         }
;;;1399       }
;;;1400     }
;;;1401   #else
;;;1402     /* Check the parameters */
;;;1403     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1404     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1405     {
;;;1406       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000004  4a05              LDR      r2,|L8.28|
000006  2901              CMP      r1,#1                 ;1404
000008  d003              BEQ      |L8.18|
;;;1407       {
;;;1408         bitstatus = SET;
;;;1409       }
;;;1410       else
;;;1411       {
;;;1412         bitstatus = RESET;
;;;1413       }
;;;1414     }
;;;1415     else
;;;1416     {
;;;1417      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00000a  68d2              LDR      r2,[r2,#0xc]
00000c  420a              TST      r2,r1
00000e  d103              BNE      |L8.24|
                  |L8.16|
;;;1418       {
;;;1419         bitstatus = SET;
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423         bitstatus = RESET;
;;;1424       }
;;;1425     }
;;;1426   #endif /* STM32F10X_XL */
;;;1427   
;;;1428     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1429     return bitstatus;
;;;1430   }
000010  4770              BX       lr
                  |L8.18|
000012  69d1              LDR      r1,[r2,#0x1c]         ;1406
000014  07c9              LSLS     r1,r1,#31             ;1406
000016  d0fb              BEQ      |L8.16|
                  |L8.24|
000018  2001              MOVS     r0,#1                 ;1408
00001a  4770              BX       lr
;;;1431   
                          ENDP

                  |L8.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1260     */
;;;1261   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  4903              LDR      r1,|L9.16|
;;;1262   {
;;;1263     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1264     
;;;1265     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000004  6809              LDR      r1,[r1,#0]
000006  0689              LSLS     r1,r1,#26
000008  d500              BPL      |L9.12|
;;;1266     {
;;;1267       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;1268     }
;;;1269     else
;;;1270     {
;;;1271       bitstatus = RESET;
;;;1272     }
;;;1273     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1274     return bitstatus; 
;;;1275   }
00000c  4770              BX       lr
;;;1276   
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1240     */
;;;1241   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  4903              LDR      r1,|L10.16|
;;;1242   {
;;;1243     FlagStatus readoutstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1244     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000004  69c9              LDR      r1,[r1,#0x1c]
000006  0789              LSLS     r1,r1,#30
000008  d500              BPL      |L10.12|
;;;1245     {
;;;1246       readoutstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L10.12|
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       readoutstatus = RESET;
;;;1251     }
;;;1252     return readoutstatus;
;;;1253   }
00000c  4770              BX       lr
;;;1254   
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1477     */
;;;1478   FLASH_Status FLASH_GetStatus(void)
000000  4908              LDR      r1,|L11.36|
;;;1479   {
;;;1480     FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;1481     
;;;1482     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L11.14|
;;;1483     {
;;;1484       flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;1485     }
;;;1486     else 
;;;1487     {  
;;;1488       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
;;;1489       { 
;;;1490         flashstatus = FLASH_ERROR_PG;
;;;1491       }
;;;1492       else 
;;;1493       {
;;;1494         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
;;;1495         {
;;;1496           flashstatus = FLASH_ERROR_WRP;
;;;1497         }
;;;1498         else
;;;1499         {
;;;1500           flashstatus = FLASH_COMPLETE;
;;;1501         }
;;;1502       }
;;;1503     }
;;;1504     /* Return the Flash Status */
;;;1505     return flashstatus;
;;;1506   }
00000c  4770              BX       lr
                  |L11.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;1488
000010  0752              LSLS     r2,r2,#29             ;1488
000012  d501              BPL      |L11.24|
000014  2002              MOVS     r0,#2                 ;1490
                  |L11.22|
000016  4770              BX       lr
                  |L11.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;1494
00001a  06c9              LSLS     r1,r1,#27             ;1494
00001c  d5fb              BPL      |L11.22|
00001e  2003              MOVS     r0,#3                 ;1496
000020  4770              BX       lr
;;;1507   
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1216     */
;;;1217   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L12.8|
;;;1218   {
;;;1219     /* Return the User Option Byte */
;;;1220     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1221   }
000006  4770              BX       lr
;;;1222   
                          ENDP

                  |L12.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1228     */
;;;1229   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L13.8|
;;;1230   {
;;;1231     /* Return the Flash write protection Register value */
;;;1232     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1233   }
000004  4770              BX       lr
;;;1234   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;281      */
;;;282    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4904              LDR      r1,|L14.20|
;;;283    {
;;;284      /* Check the parameters */
;;;285      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;286      
;;;287      /* Enable or disable the Half cycle access */
;;;288      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  680a              LDR      r2,[r1,#0]
000004  f0220208          BIC      r2,r2,#8
000008  600a              STR      r2,[r1,#0]
;;;289      FLASH->ACR |= FLASH_HalfCycleAccess;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;290    }
000010  4770              BX       lr
;;;291    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1290     */
;;;1291   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L15.20|
;;;1292   {
;;;1293   #ifdef STM32F10X_XL
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1296     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1297   
;;;1298     if((FLASH_IT & 0x80000000) != 0x0)
;;;1299     {
;;;1300       if(NewState != DISABLE)
;;;1301       {
;;;1302         /* Enable the interrupt sources */
;;;1303         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1304       }
;;;1305       else
;;;1306       {
;;;1307         /* Disable the interrupt sources */
;;;1308         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
;;;1309       }
;;;1310     }
;;;1311     else
;;;1312     {
;;;1313       if(NewState != DISABLE)
;;;1314       {
;;;1315         /* Enable the interrupt sources */
;;;1316         FLASH->CR |= FLASH_IT;
;;;1317       }
;;;1318       else
;;;1319       {
;;;1320         /* Disable the interrupt sources */
;;;1321         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1322       }
;;;1323     }
;;;1324   #else
;;;1325     /* Check the parameters */
;;;1326     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1327     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1328   
;;;1329     if(NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1330     {
;;;1331       /* Enable the interrupt sources */
;;;1332       FLASH->CR |= FLASH_IT;
;;;1333     }
;;;1334     else
;;;1335     {
;;;1336       /* Disable the interrupt sources */
;;;1337       FLASH->CR &= ~(uint32_t)FLASH_IT;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L15.12|
000008  4301              ORRS     r1,r1,r0              ;1332
00000a  e000              B        |L15.14|
                  |L15.12|
00000c  4381              BICS     r1,r1,r0
                  |L15.14|
00000e  6111              STR      r1,[r2,#0x10]         ;1332
;;;1338     }
;;;1339   #endif /* STM32F10X_XL */
;;;1340   }
000010  4770              BX       lr
;;;1341   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;372      */
;;;373    void FLASH_Lock(void)
000000  4802              LDR      r0,|L16.12|
;;;374    {
;;;375      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;376      FLASH->CR |= CR_LOCK_Set;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;377    
;;;378    #ifdef STM32F10X_XL
;;;379      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;380      FLASH->CR2 |= CR_LOCK_Set;
;;;381    #endif /* STM32F10X_XL */
;;;382    }
00000a  4770              BX       lr
;;;383    
                          ENDP

                  |L16.12|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;392      */
;;;393    void FLASH_LockBank1(void)
000000  4802              LDR      r0,|L17.12|
;;;394    {
;;;395      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;396      FLASH->CR |= CR_LOCK_Set;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;397    }
00000a  4770              BX       lr
;;;398    
                          ENDP

                  |L17.12|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;300      */
;;;301    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4904              LDR      r1,|L18.20|
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;305      
;;;306      /* Enable or disable the Prefetch Buffer */
;;;307      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  680a              LDR      r2,[r1,#0]
000004  f0220210          BIC      r2,r2,#0x10
000008  600a              STR      r2,[r1,#0]
;;;308      FLASH->ACR |= FLASH_PrefetchBuffer;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;309    }
000010  4770              BX       lr
;;;310    
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;858      */
;;;859    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;860    {
000002  4606              MOV      r6,r0
;;;861      FLASH_Status status = FLASH_COMPLETE;
;;;862      /* Check the parameters */
;;;863      assert_param(IS_FLASH_ADDRESS(Address));
;;;864    
;;;865    #ifdef STM32F10X_XL
;;;866      /* Wait for last operation to be completed */
;;;867      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;868      
;;;869      if(Address < FLASH_BANK1_END_ADDRESS)
;;;870      {
;;;871        if(status == FLASH_COMPLETE)
;;;872        {
;;;873          /* if the previous operation is completed, proceed to program the new data */
;;;874          FLASH->CR |= CR_PG_Set;
;;;875      
;;;876          *(__IO uint16_t*)Address = Data;
;;;877          /* Wait for last operation to be completed */
;;;878          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;879    
;;;880          /* Disable the PG Bit */
;;;881          FLASH->CR &= CR_PG_Reset;
;;;882        }
;;;883      }
;;;884      else
;;;885      {
;;;886        if(status == FLASH_COMPLETE)
;;;887        {
;;;888          /* if the previous operation is completed, proceed to program the new data */
;;;889          FLASH->CR2 |= CR_PG_Set;
;;;890      
;;;891          *(__IO uint16_t*)Address = Data;
;;;892          /* Wait for last operation to be completed */
;;;893          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;894    
;;;895          /* Disable the PG Bit */
;;;896          FLASH->CR2 &= CR_PG_Reset;
;;;897        }
;;;898      }
;;;899    #else
;;;900      /* Wait for last operation to be completed */
;;;901      status = FLASH_WaitForLastOperation(ProgramTimeout);
000004  f44f5700          MOV      r7,#0x2000
000008  460d              MOV      r5,r1                 ;860
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;902      
;;;903      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d10c              BNE      |L19.46|
;;;904      {
;;;905        /* if the previous operation is completed, proceed to program the new data */
;;;906        FLASH->CR |= CR_PG_Set;
000014  4c06              LDR      r4,|L19.48|
000016  6920              LDR      r0,[r4,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  6120              STR      r0,[r4,#0x10]
;;;907      
;;;908        *(__IO uint16_t*)Address = Data;
00001e  8035              STRH     r5,[r6,#0]
;;;909        /* Wait for last operation to be completed */
;;;910        status = FLASH_WaitForLastOperation(ProgramTimeout);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       FLASH_WaitForLastOperation
;;;911        
;;;912        /* Disable the PG Bit */
;;;913        FLASH->CR &= CR_PG_Reset;
000026  6921              LDR      r1,[r4,#0x10]
000028  1eba              SUBS     r2,r7,#2
00002a  4011              ANDS     r1,r1,r2
00002c  6121              STR      r1,[r4,#0x10]
                  |L19.46|
;;;914      } 
;;;915    #endif  /* STM32F10X_XL */
;;;916      
;;;917      /* Return the Program Status */
;;;918      return status;
;;;919    }
00002e  bdf0              POP      {r4-r7,pc}
;;;920    
                          ENDP

                  |L19.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;929      */
;;;930    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;931    {
000002  4606              MOV      r6,r0
;;;932      FLASH_Status status = FLASH_COMPLETE;
;;;933      /* Check the parameters */
;;;934      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;935      status = FLASH_WaitForLastOperation(ProgramTimeout);
000004  f44f5700          MOV      r7,#0x2000
000008  460d              MOV      r5,r1                 ;931
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;936    
;;;937      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d113              BNE      |L20.60|
;;;938      {
;;;939        /* Authorize the small information block programming */
;;;940        FLASH->OPTKEYR = FLASH_KEY1;
000014  4c0b              LDR      r4,|L20.68|
000016  480a              LDR      r0,|L20.64|
000018  60a0              STR      r0,[r4,#8]
;;;941        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480b              LDR      r0,|L20.72|
00001c  60a0              STR      r0,[r4,#8]
;;;942        /* Enables the Option Bytes Programming operation */
;;;943        FLASH->CR |= CR_OPTPG_Set; 
00001e  6920              LDR      r0,[r4,#0x10]
000020  f0400010          ORR      r0,r0,#0x10
000024  6120              STR      r0,[r4,#0x10]
;;;944        *(__IO uint16_t*)Address = Data;
000026  8035              STRH     r5,[r6,#0]
;;;945        
;;;946        /* Wait for last operation to be completed */
;;;947        status = FLASH_WaitForLastOperation(ProgramTimeout);
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;948        if(status != FLASH_TIMEOUT)
00002e  2805              CMP      r0,#5
000030  d004              BEQ      |L20.60|
;;;949        {
;;;950          /* if the program operation is completed, disable the OPTPG Bit */
;;;951          FLASH->CR &= CR_OPTPG_Reset;
000032  6921              LDR      r1,[r4,#0x10]
000034  f64172ef          MOV      r2,#0x1fef
000038  4011              ANDS     r1,r1,r2
00003a  6121              STR      r1,[r4,#0x10]
                  |L20.60|
;;;952        }
;;;953      }
;;;954      /* Return the Option Byte Data Program Status */
;;;955      return status;
;;;956    }
00003c  bdf0              POP      {r4-r7,pc}
;;;957    
                          ENDP

00003e  0000              DCW      0x0000
                  |L20.64|
                          DCD      0x45670123
                  |L20.68|
                          DCD      0x40022000
                  |L20.72|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;681      */
;;;682    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  e92d41f8          PUSH     {r3-r8,lr}
;;;683    {
000004  4606              MOV      r6,r0
;;;684      FLASH_Status status = FLASH_COMPLETE;
;;;685      __IO uint32_t tmp = 0;
000006  2000              MOVS     r0,#0
;;;686    
;;;687      /* Check the parameters */
;;;688      assert_param(IS_FLASH_ADDRESS(Address));
;;;689    
;;;690    #ifdef STM32F10X_XL
;;;691      if(Address < FLASH_BANK1_END_ADDRESS - 2)
;;;692      { 
;;;693        /* Wait for last operation to be completed */
;;;694        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;695        if(status == FLASH_COMPLETE)
;;;696        {
;;;697          /* if the previous operation is completed, proceed to program the new first 
;;;698            half word */
;;;699          FLASH->CR |= CR_PG_Set;
;;;700      
;;;701          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;702          /* Wait for last operation to be completed */
;;;703          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;704     
;;;705          if(status == FLASH_COMPLETE)
;;;706          {
;;;707            /* if the previous operation is completed, proceed to program the new second 
;;;708            half word */
;;;709            tmp = Address + 2;
;;;710    
;;;711            *(__IO uint16_t*) tmp = Data >> 16;
;;;712        
;;;713            /* Wait for last operation to be completed */
;;;714            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;715            
;;;716            /* Disable the PG Bit */
;;;717            FLASH->CR &= CR_PG_Reset;
;;;718          }
;;;719          else
;;;720          {
;;;721            /* Disable the PG Bit */
;;;722            FLASH->CR &= CR_PG_Reset;
;;;723           }
;;;724        }
;;;725      }
;;;726      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;727      {
;;;728        /* Wait for last operation to be completed */
;;;729        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;730    
;;;731        if(status == FLASH_COMPLETE)
;;;732        {
;;;733          /* if the previous operation is completed, proceed to program the new first 
;;;734            half word */
;;;735          FLASH->CR |= CR_PG_Set;
;;;736      
;;;737          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;738    
;;;739          /* Wait for last operation to be completed */
;;;740          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;741          
;;;742    	  /* Disable the PG Bit */
;;;743          FLASH->CR &= CR_PG_Reset;
;;;744        }
;;;745        else
;;;746        {
;;;747          /* Disable the PG Bit */
;;;748          FLASH->CR &= CR_PG_Reset;
;;;749        }
;;;750    
;;;751        /* Wait for last operation to be completed */
;;;752        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;753    
;;;754        if(status == FLASH_COMPLETE)
;;;755        {
;;;756          /* if the previous operation is completed, proceed to program the new second 
;;;757          half word */
;;;758          FLASH->CR2 |= CR_PG_Set;
;;;759          tmp = Address + 2;
;;;760    
;;;761          *(__IO uint16_t*) tmp = Data >> 16;
;;;762        
;;;763          /* Wait for last operation to be completed */
;;;764          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;765            
;;;766          /* Disable the PG Bit */
;;;767          FLASH->CR2 &= CR_PG_Reset;
;;;768        }
;;;769        else
;;;770        {
;;;771          /* Disable the PG Bit */
;;;772          FLASH->CR2 &= CR_PG_Reset;
;;;773        }
;;;774      }
;;;775      else
;;;776      {
;;;777        /* Wait for last operation to be completed */
;;;778        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;779    
;;;780        if(status == FLASH_COMPLETE)
;;;781        {
;;;782          /* if the previous operation is completed, proceed to program the new first 
;;;783            half word */
;;;784          FLASH->CR2 |= CR_PG_Set;
;;;785      
;;;786          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;787          /* Wait for last operation to be completed */
;;;788          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;789     
;;;790          if(status == FLASH_COMPLETE)
;;;791          {
;;;792            /* if the previous operation is completed, proceed to program the new second 
;;;793            half word */
;;;794            tmp = Address + 2;
;;;795    
;;;796            *(__IO uint16_t*) tmp = Data >> 16;
;;;797        
;;;798            /* Wait for last operation to be completed */
;;;799            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;800            
;;;801            /* Disable the PG Bit */
;;;802            FLASH->CR2 &= CR_PG_Reset;
;;;803          }
;;;804          else
;;;805          {
;;;806            /* Disable the PG Bit */
;;;807            FLASH->CR2 &= CR_PG_Reset;
;;;808          }
;;;809        }
;;;810      }
;;;811    #else
;;;812      /* Wait for last operation to be completed */
;;;813      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  f44f5700          MOV      r7,#0x2000
00000c  9000              STR      r0,[sp,#0]
00000e  460d              MOV      r5,r1                 ;683
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       FLASH_WaitForLastOperation
;;;814      
;;;815      if(status == FLASH_COMPLETE)
000016  2804              CMP      r0,#4
000018  d116              BNE      |L21.72|
;;;816      {
;;;817        /* if the previous operation is completed, proceed to program the new first 
;;;818        half word */
;;;819        FLASH->CR |= CR_PG_Set;
00001a  4c0c              LDR      r4,|L21.76|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400001          ORR      r0,r0,#1
000022  6120              STR      r0,[r4,#0x10]
;;;820      
;;;821        *(__IO uint16_t*)Address = (uint16_t)Data;
000024  8035              STRH     r5,[r6,#0]
;;;822        /* Wait for last operation to be completed */
;;;823        status = FLASH_WaitForLastOperation(ProgramTimeout);
000026  46b8              MOV      r8,r7
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;824     
;;;825        if(status == FLASH_COMPLETE)
;;;826        {
;;;827          /* if the previous operation is completed, proceed to program the new second 
;;;828          half word */
;;;829          tmp = Address + 2;
;;;830    
;;;831          *(__IO uint16_t*) tmp = Data >> 16;
;;;832        
;;;833          /* Wait for last operation to be completed */
;;;834          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;835            
;;;836          /* Disable the PG Bit */
;;;837          FLASH->CR &= CR_PG_Reset;
00002e  1ebf              SUBS     r7,r7,#2
000030  2804              CMP      r0,#4                 ;825
000032  d106              BNE      |L21.66|
000034  1cb6              ADDS     r6,r6,#2              ;829
000036  0c28              LSRS     r0,r5,#16             ;831
000038  9600              STR      r6,[sp,#0]            ;831
00003a  8030              STRH     r0,[r6,#0]            ;831
00003c  4640              MOV      r0,r8                 ;834
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L21.66|
;;;838        }
;;;839        else
;;;840        {
;;;841          /* Disable the PG Bit */
;;;842          FLASH->CR &= CR_PG_Reset;
000042  6921              LDR      r1,[r4,#0x10]
000044  4039              ANDS     r1,r1,r7
000046  6121              STR      r1,[r4,#0x10]
                  |L21.72|
;;;843        }
;;;844      }         
;;;845    #endif /* STM32F10X_XL */
;;;846       
;;;847      /* Return the Program Status */
;;;848      return status;
;;;849    }
000048  e8bd81f8          POP      {r3-r8,pc}
;;;850    
                          ENDP

                  |L21.76|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1049     */
;;;1050   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1051   {
000002  4606              MOV      r6,r0
;;;1052     FLASH_Status status = FLASH_COMPLETE;
;;;1053     /* Check the parameters */
;;;1054     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1055     status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2530          MOV      r5,#0xb0000
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1056     if(status == FLASH_COMPLETE)
00000e  2804              CMP      r0,#4
000010  d118              BNE      |L22.68|
;;;1057     {
;;;1058       /* Authorizes the small information block programming */
;;;1059       FLASH->OPTKEYR = FLASH_KEY1;
000012  4c1a              LDR      r4,|L22.124|
000014  4818              LDR      r0,|L22.120|
000016  60a0              STR      r0,[r4,#8]
;;;1060       FLASH->OPTKEYR = FLASH_KEY2;
000018  4819              LDR      r0,|L22.128|
00001a  60a0              STR      r0,[r4,#8]
;;;1061       FLASH->CR |= CR_OPTER_Set;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400020          ORR      r0,r0,#0x20
000022  6120              STR      r0,[r4,#0x10]
;;;1062       FLASH->CR |= CR_STRT_Set;
000024  6920              LDR      r0,[r4,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6120              STR      r0,[r4,#0x10]
;;;1063       /* Wait for last operation to be completed */
;;;1064       status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1065       if(status == FLASH_COMPLETE)
;;;1066       {
;;;1067         /* if the erase operation is completed, disable the OPTER Bit */
;;;1068         FLASH->CR &= CR_OPTER_Reset;
000032  f64171df          MOV      r1,#0x1fdf
000036  2804              CMP      r0,#4                 ;1065
000038  d005              BEQ      |L22.70|
;;;1069         /* Enable the Option Bytes Programming operation */
;;;1070         FLASH->CR |= CR_OPTPG_Set; 
;;;1071         if(NewState != DISABLE)
;;;1072         {
;;;1073           OB->RDP = 0x00;
;;;1074         }
;;;1075         else
;;;1076         {
;;;1077           OB->RDP = RDP_Key;  
;;;1078         }
;;;1079         /* Wait for last operation to be completed */
;;;1080         status = FLASH_WaitForLastOperation(EraseTimeout); 
;;;1081       
;;;1082         if(status != FLASH_TIMEOUT)
;;;1083         {
;;;1084           /* if the program operation is completed, disable the OPTPG Bit */
;;;1085           FLASH->CR &= CR_OPTPG_Reset;
;;;1086         }
;;;1087       }
;;;1088       else 
;;;1089       {
;;;1090         if(status != FLASH_TIMEOUT)
00003a  2805              CMP      r0,#5
00003c  d002              BEQ      |L22.68|
;;;1091         {
;;;1092           /* Disable the OPTER Bit */
;;;1093           FLASH->CR &= CR_OPTER_Reset;
00003e  6922              LDR      r2,[r4,#0x10]
000040  400a              ANDS     r2,r2,r1
000042  6122              STR      r2,[r4,#0x10]
                  |L22.68|
;;;1094         }
;;;1095       }
;;;1096     }
;;;1097     /* Return the protection operation Status */
;;;1098     return status;       
;;;1099   }
000044  bd70              POP      {r4-r6,pc}
                  |L22.70|
000046  6920              LDR      r0,[r4,#0x10]         ;1068
000048  4008              ANDS     r0,r0,r1              ;1068
00004a  6120              STR      r0,[r4,#0x10]         ;1068
00004c  6920              LDR      r0,[r4,#0x10]         ;1070
00004e  f0400010          ORR      r0,r0,#0x10           ;1070
000052  6120              STR      r0,[r4,#0x10]         ;1070
000054  480b              LDR      r0,|L22.132|
000056  b10e              CBZ      r6,|L22.92|
000058  2100              MOVS     r1,#0                 ;1073
00005a  e000              B        |L22.94|
                  |L22.92|
00005c  21a5              MOVS     r1,#0xa5              ;1077
                  |L22.94|
00005e  8001              STRH     r1,[r0,#0]            ;1077
000060  4628              MOV      r0,r5                 ;1080
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  2805              CMP      r0,#5                 ;1082
000068  d0ec              BEQ      |L22.68|
00006a  6921              LDR      r1,[r4,#0x10]         ;1085
00006c  f64172ef          MOV      r2,#0x1fef            ;1085
000070  4011              ANDS     r1,r1,r2              ;1085
000072  6121              STR      r1,[r4,#0x10]         ;1085
000074  bd70              POP      {r4-r6,pc}
;;;1100   
                          ENDP

000076  0000              DCW      0x0000
                  |L22.120|
                          DCD      0x45670123
                  |L22.124|
                          DCD      0x40022000
                  |L22.128|
                          DCD      0xcdef89ab
                  |L22.132|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;254      */
;;;255    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4a03              LDR      r2,|L23.16|
;;;256    {
;;;257      uint32_t tmpreg = 0;
;;;258      
;;;259      /* Check the parameters */
;;;260      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;261      
;;;262      /* Read the ACR register */
;;;263      tmpreg = FLASH->ACR;  
000002  6811              LDR      r1,[r2,#0]
;;;264      
;;;265      /* Sets the Latency value */
;;;266      tmpreg &= ACR_LATENCY_Mask;
000004  f0010138          AND      r1,r1,#0x38
;;;267      tmpreg |= FLASH_Latency;
000008  4301              ORRS     r1,r1,r0
;;;268      
;;;269      /* Write the ACR register */
;;;270      FLASH->ACR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;271    }
00000c  4770              BX       lr
;;;272    
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;319      */
;;;320    void FLASH_Unlock(void)
000000  4803              LDR      r0,|L24.16|
;;;321    {
;;;322      /* Authorize the FPEC of Bank1 Access */
;;;323      FLASH->KEYR = FLASH_KEY1;
000002  4902              LDR      r1,|L24.12|
000004  6041              STR      r1,[r0,#4]
;;;324      FLASH->KEYR = FLASH_KEY2;
000006  4903              LDR      r1,|L24.20|
000008  6041              STR      r1,[r0,#4]
;;;325    
;;;326    #ifdef STM32F10X_XL
;;;327      /* Authorize the FPEC of Bank2 Access */
;;;328      FLASH->KEYR2 = FLASH_KEY1;
;;;329      FLASH->KEYR2 = FLASH_KEY2;
;;;330    #endif /* STM32F10X_XL */
;;;331    }
00000a  4770              BX       lr
;;;332    /**
                          ENDP

                  |L24.12|
                          DCD      0x45670123
                  |L24.16|
                          DCD      0x40022000
                  |L24.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;340      */
;;;341    void FLASH_UnlockBank1(void)
000000  4803              LDR      r0,|L25.16|
;;;342    {
;;;343      /* Authorize the FPEC of Bank1 Access */
;;;344      FLASH->KEYR = FLASH_KEY1;
000002  4902              LDR      r1,|L25.12|
000004  6041              STR      r1,[r0,#4]
;;;345      FLASH->KEYR = FLASH_KEY2;
000006  4903              LDR      r1,|L25.20|
000008  6041              STR      r1,[r0,#4]
;;;346    }
00000a  4770              BX       lr
;;;347    
                          ENDP

                  |L25.12|
                          DCD      0x45670123
                  |L25.16|
                          DCD      0x40022000
                  |L25.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1118     */
;;;1119   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1120   {
;;;1121     FLASH_Status status = FLASH_COMPLETE; 
;;;1122   
;;;1123     /* Check the parameters */
;;;1124     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1125     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1126     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1127   
;;;1128     /* Authorize the small information block programming */
;;;1129     FLASH->OPTKEYR = FLASH_KEY1;
000004  4c13              LDR      r4,|L26.84|
000006  4607              MOV      r7,r0                 ;1120
000008  4811              LDR      r0,|L26.80|
00000a  4616              MOV      r6,r2                 ;1120
00000c  460d              MOV      r5,r1                 ;1120
00000e  60a0              STR      r0,[r4,#8]
;;;1130     FLASH->OPTKEYR = FLASH_KEY2;
000010  4811              LDR      r0,|L26.88|
000012  60a0              STR      r0,[r4,#8]
;;;1131     
;;;1132     /* Wait for last operation to be completed */
;;;1133     status = FLASH_WaitForLastOperation(ProgramTimeout);
000014  f44f5800          MOV      r8,#0x2000
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1134     
;;;1135     if(status == FLASH_COMPLETE)
00001e  2804              CMP      r0,#4
000020  d113              BNE      |L26.74|
;;;1136     {  
;;;1137       /* Enable the Option Bytes Programming operation */
;;;1138       FLASH->CR |= CR_OPTPG_Set; 
000022  6920              LDR      r0,[r4,#0x10]
000024  f0400010          ORR      r0,r0,#0x10
000028  6120              STR      r0,[r4,#0x10]
;;;1139              
;;;1140       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
00002a  4335              ORRS     r5,r5,r6
00002c  490b              LDR      r1,|L26.92|
00002e  433d              ORRS     r5,r5,r7
000030  f04500f8          ORR      r0,r5,#0xf8
000034  8008              STRH     r0,[r1,#0]
;;;1141     
;;;1142       /* Wait for last operation to be completed */
;;;1143       status = FLASH_WaitForLastOperation(ProgramTimeout);
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1144       if(status != FLASH_TIMEOUT)
00003c  2805              CMP      r0,#5
00003e  d004              BEQ      |L26.74|
;;;1145       {
;;;1146         /* if the program operation is completed, disable the OPTPG Bit */
;;;1147         FLASH->CR &= CR_OPTPG_Reset;
000040  6921              LDR      r1,[r4,#0x10]
000042  f64172ef          MOV      r2,#0x1fef
000046  4011              ANDS     r1,r1,r2
000048  6121              STR      r1,[r4,#0x10]
                  |L26.74|
;;;1148       }
;;;1149     }    
;;;1150     /* Return the Option Byte program Status */
;;;1151     return status;
;;;1152   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;1153   
                          ENDP

00004e  0000              DCW      0x0000
                  |L26.80|
                          DCD      0x45670123
                  |L26.84|
                          DCD      0x40022000
                  |L26.88|
                          DCD      0xcdef89ab
                  |L26.92|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=2

                  FLASH_WaitForLastBank1Operation PROC
;;;1623     */
;;;1624   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1625   { 
000002  4603              MOV      r3,r0
;;;1626     FLASH_Status status = FLASH_COMPLETE;
;;;1627      
;;;1628     /* Check for the Flash Status */
;;;1629     status = FLASH_GetBank1Status();
000004  f7fffffe          BL       FLASH_GetBank1Status
;;;1630     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1631     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
000008  e003              B        |L27.18|
;;;1632     {
;;;1633       status = FLASH_GetBank1Status();
00000a  bf00              NOP      
                  |L27.12|
00000c  f7fffffe          BL       FLASH_GetBank1Status
;;;1634       Timeout--;
000010  1e5b              SUBS     r3,r3,#1
                  |L27.18|
000012  2801              CMP      r0,#1                 ;1631
000014  d003              BEQ      |L27.30|
;;;1635     }
;;;1636     if(Timeout == 0x00 )
000016  2b00              CMP      r3,#0
000018  d100              BNE      |L27.28|
                  |L27.26|
;;;1637     {
;;;1638       status = FLASH_TIMEOUT;
00001a  2005              MOVS     r0,#5
                  |L27.28|
;;;1639     }
;;;1640     /* Return the operation status */
;;;1641     return status;
;;;1642   }
00001c  bd00              POP      {pc}
                  |L27.30|
00001e  2b00              CMP      r3,#0                 ;1631
000020  d1f4              BNE      |L27.12|
000022  e7fa              B        |L27.26|
;;;1643   
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=2

                  FLASH_WaitForLastOperation PROC
;;;1595     */
;;;1596   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1597   { 
000002  4603              MOV      r3,r0
;;;1598     FLASH_Status status = FLASH_COMPLETE;
;;;1599      
;;;1600     /* Check for the Flash Status */
;;;1601     status = FLASH_GetBank1Status();
000004  f7fffffe          BL       FLASH_GetBank1Status
;;;1602     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1603     while((status == FLASH_BUSY) && (Timeout != 0x00))
000008  e003              B        |L28.18|
;;;1604     {
;;;1605       status = FLASH_GetBank1Status();
00000a  bf00              NOP      
                  |L28.12|
00000c  f7fffffe          BL       FLASH_GetBank1Status
;;;1606       Timeout--;
000010  1e5b              SUBS     r3,r3,#1
                  |L28.18|
000012  2801              CMP      r0,#1                 ;1603
000014  d003              BEQ      |L28.30|
;;;1607     }
;;;1608     if(Timeout == 0x00 )
000016  2b00              CMP      r3,#0
000018  d100              BNE      |L28.28|
                  |L28.26|
;;;1609     {
;;;1610       status = FLASH_TIMEOUT;
00001a  2005              MOVS     r0,#5
                  |L28.28|
;;;1611     }
;;;1612     /* Return the operation status */
;;;1613     return status;
;;;1614   }
00001c  bd00              POP      {pc}
                  |L28.30|
00001e  2b00              CMP      r3,#0                 ;1603
000020  d1f4              BNE      |L28.12|
000022  e7fa              B        |L28.26|
;;;1615   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_flash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f10x_flash_c_a2a150d6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REVSH|
#line 144
|__asm___17_stm32f10x_flash_c_a2a150d6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
