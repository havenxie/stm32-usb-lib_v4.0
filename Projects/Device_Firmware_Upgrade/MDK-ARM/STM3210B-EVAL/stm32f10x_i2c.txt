; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\stm32f10x_i2c.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\DFU\inc -I..\..\..\Utilities\STM32_EVAL\Common -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL --omf_browse=.\stm3210b-eval\stm32f10x_i2c.crf ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;845      */
;;;846    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;847    {
;;;848      /* Check the parameters */
;;;849      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;850      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;851      if (NewState != DISABLE)
;;;852      {
;;;853        /* Enable the selected I2C ARP */
;;;854        I2Cx->CR1 |= CR1_ENARP_Set;
;;;855      }
;;;856      else
;;;857      {
;;;858        /* Disable the selected I2C ARP */
;;;859        I2Cx->CR1 &= CR1_ENARP_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  f0410110          ORR      r1,r1,#0x10           ;854
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L1.16|
000010  8001              STRH     r1,[r0,#0]            ;854
;;;860      }
;;;861    }
000012  4770              BX       lr
;;;862    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;447      */
;;;448    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;452      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;453      if (NewState != DISABLE)
;;;454      {
;;;455        /* Enable the acknowledgement */
;;;456        I2Cx->CR1 |= CR1_ACK_Set;
;;;457      }
;;;458      else
;;;459      {
;;;460        /* Disable the acknowledgement */
;;;461        I2Cx->CR1 &= CR1_ACK_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  f4416180          ORR      r1,r1,#0x400          ;456
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L2.16|
000010  8001              STRH     r1,[r0,#0]            ;456
;;;462      }
;;;463    }
000012  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;808      */
;;;809    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;810    {
;;;811      /* Check the parameters */
;;;812      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;813      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;814      if (NewState != DISABLE)
;;;815      {
;;;816        /* Enable the selected I2C PEC calculation */
;;;817        I2Cx->CR1 |= CR1_ENPEC_Set;
;;;818      }
;;;819      else
;;;820      {
;;;821        /* Disable the selected I2C PEC calculation */
;;;822        I2Cx->CR1 &= CR1_ENPEC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410120          ORR      r1,r1,#0x20           ;817
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;817
;;;823      }
;;;824    }
000012  4770              BX       lr
;;;825    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1035     */
;;;1036   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  4602              MOV      r2,r0
;;;1037   {
;;;1038     uint32_t lastevent = 0;
;;;1039     uint32_t flag1 = 0, flag2 = 0;
;;;1040     ErrorStatus status = ERROR;
000002  2000              MOVS     r0,#0
;;;1041   
;;;1042     /* Check the parameters */
;;;1043     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1044     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1045   
;;;1046     /* Read the I2Cx status register */
;;;1047     flag1 = I2Cx->SR1;
000004  8a93              LDRH     r3,[r2,#0x14]
;;;1048     flag2 = I2Cx->SR2;
000006  8b12              LDRH     r2,[r2,#0x18]
;;;1049     flag2 = flag2 << 16;
;;;1050   
;;;1051     /* Get the last event value from I2C status register */
;;;1052     lastevent = (flag1 | flag2) & FLAG_Mask;
000008  ea434302          ORR      r3,r3,r2,LSL #16
00000c  f023427f          BIC      r2,r3,#0xff000000
;;;1053   
;;;1054     /* Check whether the last event contains the I2C_EVENT */
;;;1055     if ((lastevent & I2C_EVENT) == I2C_EVENT)
000010  4391              BICS     r1,r1,r2
000012  d100              BNE      |L4.22|
;;;1056     {
;;;1057       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1058       status = SUCCESS;
000014  2001              MOVS     r0,#1
                  |L4.22|
;;;1059     }
;;;1060     else
;;;1061     {
;;;1062       /* ERROR: last event is different from I2C_EVENT */
;;;1063       status = ERROR;
;;;1064     }
;;;1065     /* Return status */
;;;1066     return status;
;;;1067   }
000016  4770              BX       lr
;;;1068   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1217     */
;;;1218   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1219   {
;;;1220     uint32_t flagpos = 0;
;;;1221     /* Check the parameters */
;;;1222     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1223     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1224     /* Get the I2C flag position */
;;;1225     flagpos = I2C_FLAG & FLAG_Mask;
;;;1226     /* Clear the selected I2C flag */
;;;1227     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1228   }
000004  4770              BX       lr
;;;1229   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1312     */
;;;1313   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1314   {
;;;1315     uint32_t flagpos = 0;
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1318     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1319     /* Get the I2C flag position */
;;;1320     flagpos = I2C_IT & FLAG_Mask;
;;;1321     /* Clear the selected I2C flag */
;;;1322     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1323   }
000004  4770              BX       lr
;;;1324   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;327      */
;;;328    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;329    {
;;;330      /* Check the parameters */
;;;331      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;332      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;333      if (NewState != DISABLE)
;;;334      {
;;;335        /* Enable the selected I2C peripheral */
;;;336        I2Cx->CR1 |= CR1_PE_Set;
;;;337      }
;;;338      else
;;;339      {
;;;340        /* Disable the selected I2C peripheral */
;;;341        I2Cx->CR1 &= CR1_PE_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;336
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  8001              STRH     r1,[r0,#0]            ;336
;;;342      }
;;;343    }
000012  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;351      */
;;;352    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;353    {
;;;354      /* Check the parameters */
;;;355      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;356      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;357      if (NewState != DISABLE)
;;;358      {
;;;359        /* Enable the selected I2C DMA requests */
;;;360        I2Cx->CR2 |= CR2_DMAEN_Set;
;;;361      }
;;;362      else
;;;363      {
;;;364        /* Disable the selected I2C DMA requests */
;;;365        I2Cx->CR2 &= CR2_DMAEN_Reset;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L8.12|
000006  f4416100          ORR      r1,r1,#0x800          ;360
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L8.16|
000010  8081              STRH     r1,[r0,#4]            ;360
;;;366      }
;;;367    }
000012  4770              BX       lr
;;;368    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;375      */
;;;376    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;377    {
;;;378      /* Check the parameters */
;;;379      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;380      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;381      if (NewState != DISABLE)
;;;382      {
;;;383        /* Next DMA transfer is the last transfer */
;;;384        I2Cx->CR2 |= CR2_LAST_Set;
;;;385      }
;;;386      else
;;;387      {
;;;388        /* Next DMA transfer is not the last transfer */
;;;389        I2Cx->CR2 &= CR2_LAST_Reset;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L9.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;384
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L9.16|
000010  8081              STRH     r1,[r0,#4]            ;384
;;;390      }
;;;391    }
000012  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;167      */
;;;168    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  4909              LDR      r1,|L10.40|
;;;169    {
000002  b510              PUSH     {r4,lr}
;;;170      /* Check the parameters */
;;;171      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;172    
;;;173      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
;;;174      {
;;;175        /* Enable I2C1 reset state */
;;;176        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;177        /* Release I2C1 from reset state */
;;;178        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;179      }
;;;180      else
;;;181      {
;;;182        /* Enable I2C2 reset state */
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000006  f04f0101          MOV      r1,#1
00000a  d101              BNE      |L10.16|
00000c  054c              LSLS     r4,r1,#21             ;176
00000e  e001              B        |L10.20|
                  |L10.16|
000010  f44f0480          MOV      r4,#0x400000
                  |L10.20|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;184        /* Release I2C2 from reset state */
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00001a  4620              MOV      r0,r4
00001c  e8bd4010          POP      {r4,lr}
000020  2100              MOVS     r1,#0
000022  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;186      }
;;;187    }
;;;188    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40005400

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;497      */
;;;498    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;499    {
;;;500      /* Check the parameters */
;;;501      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;502      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;503      if (NewState != DISABLE)
;;;504      {
;;;505        /* Enable dual addressing mode */
;;;506        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Disable dual addressing mode */
;;;511        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L11.12|
000006  f0410101          ORR      r1,r1,#1              ;506
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L11.16|
000010  8181              STRH     r1,[r0,#0xc]          ;506
;;;512      }
;;;513    }
000012  4770              BX       lr
;;;514    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;895      */
;;;896    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;897    {
;;;898      /* Check the parameters */
;;;899      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;900      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;901      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;902      {
;;;903        /* I2C fast mode Tlow/Thigh=2 */
;;;904        I2Cx->CCR &= I2C_DutyCycle_2;
;;;905      }
;;;906      else
;;;907      {
;;;908        /* I2C fast mode Tlow/Thigh=16/9 */
;;;909        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  d002              BEQ      |L12.14|
000008  f4214180          BIC      r1,r1,#0x4000         ;904
00000c  e001              B        |L12.18|
                  |L12.14|
00000e  f4414180          ORR      r1,r1,#0x4000
                  |L12.18|
000012  8381              STRH     r1,[r0,#0x1c]         ;904
;;;910      }
;;;911    }
000014  4770              BX       lr
;;;912    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;521      */
;;;522    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;527      if (NewState != DISABLE)
;;;528      {
;;;529        /* Enable generall call */
;;;530        I2Cx->CR1 |= CR1_ENGC_Set;
;;;531      }
;;;532      else
;;;533      {
;;;534        /* Disable generall call */
;;;535        I2Cx->CR1 &= CR1_ENGC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L13.12|
000006  f0410140          ORR      r1,r1,#0x40           ;530
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0210140          BIC      r1,r1,#0x40
                  |L13.16|
000010  8001              STRH     r1,[r0,#0]            ;530
;;;536      }
;;;537    }
000012  4770              BX       lr
;;;538    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;399      */
;;;400    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;404      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;405      if (NewState != DISABLE)
;;;406      {
;;;407        /* Generate a START condition */
;;;408        I2Cx->CR1 |= CR1_START_Set;
;;;409      }
;;;410      else
;;;411      {
;;;412        /* Disable the START condition generation */
;;;413        I2Cx->CR1 &= CR1_START_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L14.12|
000006  f4417180          ORR      r1,r1,#0x100          ;408
00000a  e001              B        |L14.16|
                  |L14.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L14.16|
000010  8001              STRH     r1,[r0,#0]            ;408
;;;414      }
;;;415    }
000012  4770              BX       lr
;;;416    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;423      */
;;;424    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;428      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;429      if (NewState != DISABLE)
;;;430      {
;;;431        /* Generate a STOP condition */
;;;432        I2Cx->CR1 |= CR1_STOP_Set;
;;;433      }
;;;434      else
;;;435      {
;;;436        /* Disable the STOP condition generation */
;;;437        I2Cx->CR1 &= CR1_STOP_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f4417100          ORR      r1,r1,#0x200          ;432
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f4217100          BIC      r1,r1,#0x200
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;432
;;;438      }
;;;439    }
000012  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1138     */
;;;1139   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1140   {
000002  4602              MOV      r2,r0
;;;1141     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1142     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1143   
;;;1144     /* Check the parameters */
;;;1145     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1146     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1147   
;;;1148     /* Get the I2Cx peripheral base address */
;;;1149     i2cxbase = (uint32_t)I2Cx;
;;;1150     
;;;1151     /* Read flag register index */
;;;1152     i2creg = I2C_FLAG >> 28;
000006  9200              STR      r2,[sp,#0]
000008  0f0a              LSRS     r2,r1,#28
;;;1153     
;;;1154     /* Get bit[23:0] of the flag */
;;;1155     I2C_FLAG &= FLAG_Mask;
00000a  f021417f          BIC      r1,r1,#0xff000000
00000e  9201              STR      r2,[sp,#4]            ;1140
000010  d002              BEQ      |L16.24|
;;;1156     
;;;1157     if(i2creg != 0)
;;;1158     {
;;;1159       /* Get the I2Cx SR1 register address */
;;;1160       i2cxbase += 0x14;
000012  9a00              LDR      r2,[sp,#0]
000014  3214              ADDS     r2,r2,#0x14
000016  e002              B        |L16.30|
                  |L16.24|
;;;1161     }
;;;1162     else
;;;1163     {
;;;1164       /* Flag in I2Cx SR2 Register */
;;;1165       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
;;;1166       /* Get the I2Cx SR2 register address */
;;;1167       i2cxbase += 0x18;
000018  9a00              LDR      r2,[sp,#0]
00001a  0c09              LSRS     r1,r1,#16             ;1165
00001c  3218              ADDS     r2,r2,#0x18
                  |L16.30|
;;;1168     }
;;;1169     
;;;1170     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00001e  9200              STR      r2,[sp,#0]
000020  6812              LDR      r2,[r2,#0]
000022  420a              TST      r2,r1
000024  d000              BEQ      |L16.40|
;;;1171     {
;;;1172       /* I2C_FLAG is set */
;;;1173       bitstatus = SET;
000026  2001              MOVS     r0,#1
                  |L16.40|
;;;1174     }
;;;1175     else
;;;1176     {
;;;1177       /* I2C_FLAG is reset */
;;;1178       bitstatus = RESET;
;;;1179     }
;;;1180     
;;;1181     /* Return the I2C_FLAG status */
;;;1182     return  bitstatus;
;;;1183   }
000028  bd0c              POP      {r2,r3,pc}
;;;1184   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1251     */
;;;1252   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1253   {
000002  4603              MOV      r3,r0
;;;1254     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1255     uint32_t enablestatus = 0;
;;;1256   
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1259     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1260   
;;;1261     /* Check if the interrupt source is enabled or not */
;;;1262     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
000006  889a              LDRH     r2,[r3,#4]
000008  f44f64e0          MOV      r4,#0x700
00000c  ea044411          AND      r4,r4,r1,LSR #16
;;;1263     
;;;1264     /* Get bit[23:0] of the flag */
;;;1265     I2C_IT &= FLAG_Mask;
;;;1266   
;;;1267     /* Check the status of the specified I2C flag */
;;;1268     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000010  8a9b              LDRH     r3,[r3,#0x14]
000012  4022              ANDS     r2,r2,r4              ;1262
000014  f021417f          BIC      r1,r1,#0xff000000     ;1265
000018  420b              TST      r3,r1
00001a  d002              BEQ      |L17.34|
00001c  2a00              CMP      r2,#0
00001e  d000              BEQ      |L17.34|
;;;1269     {
;;;1270       /* I2C_IT is set */
;;;1271       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L17.34|
;;;1272     }
;;;1273     else
;;;1274     {
;;;1275       /* I2C_IT is reset */
;;;1276       bitstatus = RESET;
;;;1277     }
;;;1278     /* Return the I2C_IT status */
;;;1279     return  bitstatus;
;;;1280   }
000022  bd10              POP      {r4,pc}
;;;1281   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1083     */
;;;1084   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;1085   {
;;;1086     uint32_t lastevent = 0;
;;;1087     uint32_t flag1 = 0, flag2 = 0;
;;;1088   
;;;1089     /* Check the parameters */
;;;1090     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1091   
;;;1092     /* Read the I2Cx status register */
;;;1093     flag1 = I2Cx->SR1;
;;;1094     flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;1095     flag2 = flag2 << 16;
;;;1096   
;;;1097     /* Get the last event value from I2C status register */
;;;1098     lastevent = (flag1 | flag2) & FLAG_Mask;
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  f021407f          BIC      r0,r1,#0xff000000
;;;1099   
;;;1100     /* Return status */
;;;1101     return lastevent;
;;;1102   }
00000c  4770              BX       lr
;;;1103   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;830      */
;;;831    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;832    {
;;;833      /* Check the parameters */
;;;834      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;835      /* Return the selected I2C PEC value */
;;;836      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;837    }
000004  4770              BX       lr
;;;838    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;550      */
;;;551    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;552    {
;;;553      /* Check the parameters */
;;;554      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;555      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;556      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;557      
;;;558      if (NewState != DISABLE)
;;;559      {
;;;560        /* Enable the selected I2C interrupts */
;;;561        I2Cx->CR2 |= I2C_IT;
;;;562      }
;;;563      else
;;;564      {
;;;565        /* Disable the selected I2C interrupts */
;;;566        I2Cx->CR2 &= (uint16_t)~I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L20.10|
000006  430a              ORRS     r2,r2,r1              ;561
000008  e000              B        |L20.12|
                  |L20.10|
00000a  438a              BICS     r2,r2,r1
                  |L20.12|
00000c  8082              STRH     r2,[r0,#4]            ;561
;;;567      }
;;;568    }
00000e  4770              BX       lr
;;;569    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;196      */
;;;197    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
000002  4604              MOV      r4,r0
;;;199      uint16_t tmpreg = 0, freqrange = 0;
;;;200      uint16_t result = 0x04;
;;;201      uint32_t pclk1 = 8000000;
;;;202      RCC_ClocksTypeDef  rcc_clocks;
;;;203      /* Check the parameters */
;;;204      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;205      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;206      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;207      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;208      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;209      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;210      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;211    
;;;212    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;213      /* Get the I2Cx CR2 value */
;;;214      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  b086              SUB      sp,sp,#0x18           ;198
000008  460d              MOV      r5,r1                 ;198
;;;215      /* Clear frequency FREQ[5:0] bits */
;;;216      tmpreg &= CR2_FREQ_Reset;
00000a  f020063f          BIC      r6,r0,#0x3f
;;;217      /* Get pclk1 frequency value */
;;;218      RCC_GetClocksFreq(&rcc_clocks);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       RCC_GetClocksFreq
;;;219      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;220      /* Set frequency bits depending on pclk1 value */
;;;221      freqrange = (uint16_t)(pclk1 / 1000000);
000014  4926              LDR      r1,|L21.176|
000016  9802              LDR      r0,[sp,#8]
000018  fbb0f1f1          UDIV     r1,r0,r1
00001c  b289              UXTH     r1,r1
;;;222      tmpreg |= freqrange;
00001e  430e              ORRS     r6,r6,r1
;;;223      /* Write to I2Cx CR2 */
;;;224      I2Cx->CR2 = tmpreg;
000020  80a6              STRH     r6,[r4,#4]
;;;225    
;;;226    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;227      /* Disable the selected I2C peripheral to configure TRISE */
;;;228      I2Cx->CR1 &= CR1_PE_Reset;
000022  8822              LDRH     r2,[r4,#0]
000024  f0220201          BIC      r2,r2,#1
000028  8022              STRH     r2,[r4,#0]
;;;229      /* Reset tmpreg value */
;;;230      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;231      tmpreg = 0;
;;;232    
;;;233      /* Configure speed in standard mode */
;;;234      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00002a  4b22              LDR      r3,|L21.180|
00002c  682a              LDR      r2,[r5,#0]
00002e  429a              CMP      r2,r3
000030  d81c              BHI      |L21.108|
;;;235      {
;;;236        /* Standard mode speed calculate */
;;;237        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000032  0052              LSLS     r2,r2,#1
000034  fbb0f0f2          UDIV     r0,r0,r2
000038  b280              UXTH     r0,r0
;;;238        /* Test if CCR value is under 0x4*/
;;;239        if (result < 0x04)
00003a  2804              CMP      r0,#4
00003c  d200              BCS      |L21.64|
;;;240        {
;;;241          /* Set minimum allowed value */
;;;242          result = 0x04;  
00003e  2004              MOVS     r0,#4
                  |L21.64|
;;;243        }
;;;244        /* Set speed value for standard mode */
;;;245        tmpreg |= result;	  
;;;246        /* Set Maximum Rise Time for standard mode */
;;;247        I2Cx->TRISE = freqrange + 1; 
000040  1c49              ADDS     r1,r1,#1
000042  8421              STRH     r1,[r4,#0x20]
;;;248      }
;;;249      /* Configure speed in fast mode */
;;;250      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;251      {
;;;252        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;253        {
;;;254          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;255          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;256        }
;;;257        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;258        {
;;;259          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;260          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;261          /* Set DUTY bit */
;;;262          result |= I2C_DutyCycle_16_9;
;;;263        }
;;;264    
;;;265        /* Test if CCR value is under 0x1*/
;;;266        if ((result & CCR_CCR_Set) == 0)
;;;267        {
;;;268          /* Set minimum allowed value */
;;;269          result |= (uint16_t)0x0001;  
;;;270        }
;;;271        /* Set speed value and set F/S bit for fast mode */
;;;272        tmpreg |= (uint16_t)(result | CCR_FS_Set);
;;;273        /* Set Maximum Rise Time for fast mode */
;;;274        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
;;;275      }
;;;276    
;;;277      /* Write to I2Cx CCR */
;;;278      I2Cx->CCR = tmpreg;
000044  83a0              STRH     r0,[r4,#0x1c]
;;;279      /* Enable the selected I2C peripheral */
;;;280      I2Cx->CR1 |= CR1_PE_Set;
000046  8820              LDRH     r0,[r4,#0]
000048  f0400001          ORR      r0,r0,#1
00004c  8020              STRH     r0,[r4,#0]
;;;281    
;;;282    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;283      /* Get the I2Cx CR1 value */
;;;284      tmpreg = I2Cx->CR1;
00004e  8821              LDRH     r1,[r4,#0]
;;;285      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;286      tmpreg &= CR1_CLEAR_Mask;
000050  f64f30f5          MOV      r0,#0xfbf5
000054  4001              ANDS     r1,r1,r0
;;;287      /* Configure I2Cx: mode and acknowledgement */
;;;288      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;289      /* Set ACK bit according to I2C_Ack value */
;;;290      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000056  88a8              LDRH     r0,[r5,#4]
000058  896a              LDRH     r2,[r5,#0xa]
00005a  4310              ORRS     r0,r0,r2
00005c  4308              ORRS     r0,r0,r1
;;;291      /* Write to I2Cx CR1 */
;;;292      I2Cx->CR1 = tmpreg;
00005e  8020              STRH     r0,[r4,#0]
;;;293    
;;;294    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;295      /* Set I2Cx Own Address1 and acknowledged address */
;;;296      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
000060  89a8              LDRH     r0,[r5,#0xc]
000062  8929              LDRH     r1,[r5,#8]
000064  4308              ORRS     r0,r0,r1
000066  8120              STRH     r0,[r4,#8]
;;;297    }
000068  b006              ADD      sp,sp,#0x18
00006a  bd70              POP      {r4-r6,pc}
                  |L21.108|
00006c  88eb              LDRH     r3,[r5,#6]            ;252
00006e  f5a3463f          SUB      r6,r3,#0xbf00         ;252
000072  3eff              SUBS     r6,r6,#0xff           ;252
000074  d105              BNE      |L21.130|
000076  eb020242          ADD      r2,r2,r2,LSL #1       ;255
00007a  fbb0f0f2          UDIV     r0,r0,r2              ;255
00007e  b280              UXTH     r0,r0                 ;255
000080  e008              B        |L21.148|
                  |L21.130|
000082  eb0203c2          ADD      r3,r2,r2,LSL #3       ;260
000086  eb031202          ADD      r2,r3,r2,LSL #4       ;260
00008a  fbb0f0f2          UDIV     r0,r0,r2              ;260
00008e  b280              UXTH     r0,r0                 ;260
000090  f4404080          ORR      r0,r0,#0x4000         ;262
                  |L21.148|
000094  0502              LSLS     r2,r0,#20             ;266
000096  d101              BNE      |L21.156|
000098  f0400001          ORR      r0,r0,#1              ;269
                  |L21.156|
00009c  f44f7296          MOV      r2,#0x12c             ;274
0000a0  4351              MULS     r1,r2,r1              ;274
0000a2  f44f727a          MOV      r2,#0x3e8             ;274
0000a6  fbb1f1f2          UDIV     r1,r1,r2              ;274
0000aa  f4404000          ORR      r0,r0,#0x8000         ;272
0000ae  e7c7              B        |L21.64|
;;;298    
                          ENDP

                  |L21.176|
                          DCD      0x000f4240
                  |L21.180|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;701      */
;;;702    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;706      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;707      
;;;708      /* Check the input parameter */
;;;709      if (I2C_NACKPosition == I2C_NACKPosition_Next)
;;;710      {
;;;711        /* Next byte in shift register is the last received byte */
;;;712        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Current byte in shift register is the last received byte */
;;;717        I2Cx->CR1 &= I2C_NACKPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L22.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L22.12|
00000c  8001              STRH     r1,[r0,#0]            ;712
;;;718      }
;;;719    }
00000e  4770              BX       lr
                  |L22.16|
000010  f4416100          ORR      r1,r1,#0x800          ;712
000014  e7fa              B        |L22.12|
;;;720    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;470      */
;;;471    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;472    {
;;;473      uint16_t tmpreg = 0;
;;;474    
;;;475      /* Check the parameters */
;;;476      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;477    
;;;478      /* Get the old register value */
;;;479      tmpreg = I2Cx->OAR2;
;;;480    
;;;481      /* Reset I2Cx Own address2 bit [7:1] */
;;;482      tmpreg &= OAR2_ADD2_Reset;
;;;483    
;;;484      /* Set I2Cx Own address2 */
;;;485      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;482
00000a  4311              ORRS     r1,r1,r2
;;;486    
;;;487      /* Store the new register value */
;;;488      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;489    }
00000e  4770              BX       lr
;;;490    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;784      */
;;;785    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;786    {
;;;787      /* Check the parameters */
;;;788      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;789      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;790      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;791      {
;;;792        /* Next byte in shift register is PEC */
;;;793        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;794      }
;;;795      else
;;;796      {
;;;797        /* Current byte in shift register is PEC */
;;;798        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L24.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L24.12|
00000c  8001              STRH     r1,[r0,#0]            ;793
;;;799      }
;;;800    }
00000e  4770              BX       lr
                  |L24.16|
000010  f4416100          ORR      r1,r1,#0x800          ;793
000014  e7fa              B        |L24.12|
;;;801    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;641      */
;;;642    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;643    {
;;;644      __IO uint32_t tmp = 0;
;;;645    
;;;646      /* Check the parameters */
;;;647      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;648      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;649    
;;;650      tmp = (uint32_t) I2Cx;
;;;651      tmp += I2C_Register;
000002  4408              ADD      r0,r0,r1
;;;652    
;;;653      /* Return the selected register value */
;;;654      return (*(__IO uint16_t *) tmp);
000004  9000              STR      r0,[sp,#0]
000006  8800              LDRH     r0,[r0,#0]
;;;655    }
000008  bd08              POP      {r3,pc}
;;;656    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;588      */
;;;589    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;590    {
;;;591      /* Check the parameters */
;;;592      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;593      /* Return the data in the DR register */
;;;594      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;595    }
000004  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;729      */
;;;730    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;731    {
;;;732      /* Check the parameters */
;;;733      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;734      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;735      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;736      {
;;;737        /* Drive the SMBusAlert pin Low */
;;;738        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;739      }
;;;740      else
;;;741      {
;;;742        /* Drive the SMBusAlert pin High  */
;;;743        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L27.16|
000008  f4215100          BIC      r1,r1,#0x2000
                  |L27.12|
00000c  8001              STRH     r1,[r0,#0]            ;738
;;;744      }
;;;745    }
00000e  4770              BX       lr
                  |L27.16|
000010  f4415100          ORR      r1,r1,#0x2000         ;738
000014  e7fa              B        |L27.12|
;;;746    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;606      */
;;;607    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L28.8|
;;;608    {
;;;609      /* Check the parameters */
;;;610      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;611      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;612      /* Test on the direction to set/reset the read/write bit */
;;;613      if (I2C_Direction != I2C_Direction_Transmitter)
;;;614      {
;;;615        /* Set the address bit0 for read */
;;;616        Address |= OAR1_ADD0_Set;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L28.12|
                  |L28.8|
;;;617      }
;;;618      else
;;;619      {
;;;620        /* Reset the address bit0 for write */
;;;621        Address &= OAR1_ADD0_Reset;
000008  f00101fe          AND      r1,r1,#0xfe
                  |L28.12|
;;;622      }
;;;623      /* Send the address */
;;;624      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;625    }
00000e  4770              BX       lr
;;;626    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;575      */
;;;576    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;577    {
;;;578      /* Check the parameters */
;;;579      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;580      /* Write in the DR register the data to be sent */
;;;581      I2Cx->DR = Data;
;;;582    }
000002  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;663      */
;;;664    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;665    {
;;;666      /* Check the parameters */
;;;667      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;668      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;669      if (NewState != DISABLE)
;;;670      {
;;;671        /* Peripheral under reset */
;;;672        I2Cx->CR1 |= CR1_SWRST_Set;
;;;673      }
;;;674      else
;;;675      {
;;;676        /* Peripheral not under reset */
;;;677        I2Cx->CR1 &= CR1_SWRST_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L30.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;672
00000a  e001              B        |L30.16|
                  |L30.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L30.16|
000010  8001              STRH     r1,[r0,#0]            ;672
;;;678      }
;;;679    }
000012  4770              BX       lr
;;;680    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;869      */
;;;870    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;871    {
;;;872      /* Check the parameters */
;;;873      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;874      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;875      if (NewState == DISABLE)
;;;876      {
;;;877        /* Enable the selected I2C Clock stretching */
;;;878        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
;;;879      }
;;;880      else
;;;881      {
;;;882        /* Disable the selected I2C Clock stretching */
;;;883        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d003              BEQ      |L31.14|
000006  f0210180          BIC      r1,r1,#0x80
                  |L31.10|
00000a  8001              STRH     r1,[r0,#0]            ;878
;;;884      }
;;;885    }
00000c  4770              BX       lr
                  |L31.14|
00000e  f0410180          ORR      r1,r1,#0x80           ;878
000012  e7fa              B        |L31.10|
;;;886    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;303      */
;;;304    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;305    {
;;;306    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;307      /* initialize the I2C_ClockSpeed member */
;;;308      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;309      /* Initialize the I2C_Mode member */
;;;310      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;311      /* Initialize the I2C_DutyCycle member */
;;;312      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;313      /* Initialize the I2C_OwnAddress1 member */
;;;314      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;315      /* Initialize the I2C_Ack member */
;;;316      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;317      /* Initialize the I2C_AcknowledgedAddress member */
;;;318      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;319    }
00001a  4770              BX       lr
;;;320    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;753      */
;;;754    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;755    {
;;;756      /* Check the parameters */
;;;757      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;758      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;759      if (NewState != DISABLE)
;;;760      {
;;;761        /* Enable the selected I2C PEC transmission */
;;;762        I2Cx->CR1 |= CR1_PEC_Set;
;;;763      }
;;;764      else
;;;765      {
;;;766        /* Disable the selected I2C PEC transmission */
;;;767        I2Cx->CR1 &= CR1_PEC_Reset;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L33.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;762
00000a  e001              B        |L33.16|
                  |L33.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L33.16|
000010  8001              STRH     r1,[r0,#0]            ;762
;;;768      }
;;;769    }
000012  4770              BX       lr
;;;770    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_i2c.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_i2c_c_7174d409____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_i2c_c_7174d409____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_i2c_c_7174d409____REVSH|
#line 144
|__asm___15_stm32f10x_i2c_c_7174d409____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
