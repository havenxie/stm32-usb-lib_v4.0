; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\stm32f10x_sdio.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\stm32f10x_sdio.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\DFU\inc -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_sdio.c]
                          THUMB

                          AREA ||i.SDIO_CEATAITCmd||, CODE, READONLY, ALIGN=2

                  SDIO_CEATAITCmd PROC
;;;618      */
;;;619    void SDIO_CEATAITCmd(FunctionalState NewState)
000000  2101              MOVS     r1,#1
;;;620    { 
;;;621      /* Check the parameters */
;;;622      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;623      
;;;624      *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
000002  4381              BICS     r1,r1,r0
000004  4801              LDR      r0,|L1.12|
000006  6001              STR      r1,[r0,#0]
;;;625    }
000008  4770              BX       lr
;;;626    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x423001b4

                          AREA ||i.SDIO_ClearFlag||, CODE, READONLY, ALIGN=2

                  SDIO_ClearFlag PROC
;;;708      */
;;;709    void SDIO_ClearFlag(uint32_t SDIO_FLAG)
000000  4901              LDR      r1,|L2.8|
;;;710    { 
;;;711      /* Check the parameters */
;;;712      assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
;;;713       
;;;714      SDIO->ICR = SDIO_FLAG;
000002  6388              STR      r0,[r1,#0x38]
;;;715    }
000004  4770              BX       lr
;;;716    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x40018000

                          AREA ||i.SDIO_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  SDIO_ClearITPendingBit PROC
;;;783      */
;;;784    void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
000000  4901              LDR      r1,|L3.8|
;;;785    { 
;;;786      /* Check the parameters */
;;;787      assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
;;;788       
;;;789      SDIO->ICR = SDIO_IT;
000002  6388              STR      r0,[r1,#0x38]
;;;790    }
000004  4770              BX       lr
;;;791    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x40018000

                          AREA ||i.SDIO_ClockCmd||, CODE, READONLY, ALIGN=2

                  SDIO_ClockCmd PROC
;;;240      */
;;;241    void SDIO_ClockCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L4.8|
;;;242    {
;;;243      /* Check the parameters */
;;;244      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;245      
;;;246      *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;247    }
000004  4770              BX       lr
;;;248    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x423000a0

                          AREA ||i.SDIO_CmdStructInit||, CODE, READONLY, ALIGN=1

                  SDIO_CmdStructInit PROC
;;;386      */
;;;387    void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
000000  2100              MOVS     r1,#0
;;;388    {
;;;389      /* SDIO_CmdInitStruct members default value */
;;;390      SDIO_CmdInitStruct->SDIO_Argument = 0x00;
;;;391      SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
000002  6001              STR      r1,[r0,#0]
;;;392      SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
000004  6041              STR      r1,[r0,#4]
;;;393      SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
000006  6081              STR      r1,[r0,#8]
;;;394      SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
000008  60c1              STR      r1,[r0,#0xc]
00000a  6101              STR      r1,[r0,#0x10]
;;;395    }
00000c  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.SDIO_CommandCompletionCmd||, CODE, READONLY, ALIGN=2

                  SDIO_CommandCompletionCmd PROC
;;;605      */
;;;606    void SDIO_CommandCompletionCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L6.8|
;;;607    { 
;;;608      /* Check the parameters */
;;;609      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;610      
;;;611      *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;612    }
000004  4770              BX       lr
;;;613    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      0x423001b0

                          AREA ||i.SDIO_DMACmd||, CODE, READONLY, ALIGN=2

                  SDIO_DMACmd PROC
;;;335      */
;;;336    void SDIO_DMACmd(FunctionalState NewState)
000000  4901              LDR      r1,|L7.8|
;;;337    {
;;;338      /* Check the parameters */
;;;339      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;340      
;;;341      *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;342    }
000004  4770              BX       lr
;;;343    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x4230058c

                          AREA ||i.SDIO_DataConfig||, CODE, READONLY, ALIGN=2

                  SDIO_DataConfig PROC
;;;435      */
;;;436    void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
000000  b510              PUSH     {r4,lr}
;;;437    {
;;;438      uint32_t tmpreg = 0;
;;;439      
;;;440      /* Check the parameters */
;;;441      assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
;;;442      assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
;;;443      assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
;;;444      assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
;;;445      assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
;;;446    
;;;447    /*---------------------------- SDIO DTIMER Configuration ---------------------*/
;;;448      /* Set the SDIO Data TimeOut value */
;;;449      SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
000002  4a09              LDR      r2,|L8.40|
000004  6801              LDR      r1,[r0,#0]
000006  6251              STR      r1,[r2,#0x24]
;;;450    
;;;451    /*---------------------------- SDIO DLEN Configuration -----------------------*/
;;;452      /* Set the SDIO DataLength value */
;;;453      SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
000008  6841              LDR      r1,[r0,#4]
00000a  6291              STR      r1,[r2,#0x28]
;;;454    
;;;455    /*---------------------------- SDIO DCTRL Configuration ----------------------*/  
;;;456      /* Get the SDIO DCTRL value */
;;;457      tmpreg = SDIO->DCTRL;
00000c  6ad1              LDR      r1,[r2,#0x2c]
;;;458      /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
;;;459      tmpreg &= DCTRL_CLEAR_MASK;
00000e  f02103f7          BIC      r3,r1,#0xf7
000012  e9d01402          LDRD     r1,r4,[r0,#8]
;;;460      /* Set DEN bit according to SDIO_DPSM value */
;;;461      /* Set DTMODE bit according to SDIO_TransferMode value */
;;;462      /* Set DTDIR bit according to SDIO_TransferDir value */
;;;463      /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
;;;464      tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
000016  4321              ORRS     r1,r1,r4
000018  e9d04004          LDRD     r4,r0,[r0,#0x10]
00001c  4304              ORRS     r4,r4,r0
00001e  4321              ORRS     r1,r1,r4
000020  4319              ORRS     r1,r1,r3
;;;465               | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
;;;466    
;;;467      /* Write to SDIO DCTRL */
;;;468      SDIO->DCTRL = tmpreg;
000022  62d1              STR      r1,[r2,#0x2c]
;;;469    }
000024  bd10              POP      {r4,pc}
;;;470    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x40018000

                          AREA ||i.SDIO_DataStructInit||, CODE, READONLY, ALIGN=1

                  SDIO_DataStructInit PROC
;;;476      */
;;;477    void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;478    {
;;;479      /* SDIO_DataInitStruct members default value */
;;;480      SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
;;;481      SDIO_DataInitStruct->SDIO_DataLength = 0x00;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
;;;482      SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
000008  6041              STR      r1,[r0,#4]
;;;483      SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
00000a  6081              STR      r1,[r0,#8]
;;;484      SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
00000c  60c1              STR      r1,[r0,#0xc]
;;;485      SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
00000e  6101              STR      r1,[r0,#0x10]
000010  6141              STR      r1,[r0,#0x14]
;;;486    }
000012  4770              BX       lr
;;;487    
                          ENDP


                          AREA ||i.SDIO_DeInit||, CODE, READONLY, ALIGN=2

                  SDIO_DeInit PROC
;;;166      */
;;;167    void SDIO_DeInit(void)
000000  4806              LDR      r0,|L10.28|
;;;168    {
;;;169      SDIO->POWER = 0x00000000;
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
;;;170      SDIO->CLKCR = 0x00000000;
000006  6041              STR      r1,[r0,#4]
;;;171      SDIO->ARG = 0x00000000;
000008  6081              STR      r1,[r0,#8]
;;;172      SDIO->CMD = 0x00000000;
00000a  60c1              STR      r1,[r0,#0xc]
;;;173      SDIO->DTIMER = 0x00000000;
00000c  6241              STR      r1,[r0,#0x24]
;;;174      SDIO->DLEN = 0x00000000;
00000e  6281              STR      r1,[r0,#0x28]
;;;175      SDIO->DCTRL = 0x00000000;
000010  62c1              STR      r1,[r0,#0x2c]
;;;176      SDIO->ICR = 0x00C007FF;
000012  4a03              LDR      r2,|L10.32|
000014  6382              STR      r2,[r0,#0x38]
;;;177      SDIO->MASK = 0x00000000;
000016  63c1              STR      r1,[r0,#0x3c]
;;;178    }
000018  4770              BX       lr
;;;179    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40018000
                  |L10.32|
                          DCD      0x00c007ff

                          AREA ||i.SDIO_GetCommandResponse||, CODE, READONLY, ALIGN=2

                  SDIO_GetCommandResponse PROC
;;;401      */
;;;402    uint8_t SDIO_GetCommandResponse(void)
000000  4801              LDR      r0,|L11.8|
;;;403    {
;;;404      return (uint8_t)(SDIO->RESPCMD);
000002  6900              LDR      r0,[r0,#0x10]
000004  b2c0              UXTB     r0,r0
;;;405    }
000006  4770              BX       lr
;;;406    
                          ENDP

                  |L11.8|
                          DCD      0x40018000

                          AREA ||i.SDIO_GetDataCounter||, CODE, READONLY, ALIGN=2

                  SDIO_GetDataCounter PROC
;;;492      */
;;;493    uint32_t SDIO_GetDataCounter(void)
000000  4801              LDR      r0,|L12.8|
;;;494    { 
;;;495      return SDIO->DCOUNT;
000002  6b00              LDR      r0,[r0,#0x30]
;;;496    }
000004  4770              BX       lr
;;;497    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40018000

                          AREA ||i.SDIO_GetFIFOCount||, CODE, READONLY, ALIGN=2

                  SDIO_GetFIFOCount PROC
;;;522      */
;;;523    uint32_t SDIO_GetFIFOCount(void)
000000  4801              LDR      r0,|L13.8|
;;;524    { 
;;;525      return SDIO->FIFOCNT;
000002  6c80              LDR      r0,[r0,#0x48]
;;;526    }
000004  4770              BX       lr
;;;527    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40018000

                          AREA ||i.SDIO_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  SDIO_GetFlagStatus PROC
;;;670      */
;;;671    FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
000000  4a03              LDR      r2,|L14.16|
;;;672    { 
000002  4601              MOV      r1,r0
;;;673      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;674      
;;;675      /* Check the parameters */
;;;676      assert_param(IS_SDIO_FLAG(SDIO_FLAG));
;;;677      
;;;678      if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
000006  6b52              LDR      r2,[r2,#0x34]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L14.14|
;;;679      {
;;;680        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L14.14|
;;;681      }
;;;682      else
;;;683      {
;;;684        bitstatus = RESET;
;;;685      }
;;;686      return bitstatus;
;;;687    }
00000e  4770              BX       lr
;;;688    
                          ENDP

                  |L14.16|
                          DCD      0x40018000

                          AREA ||i.SDIO_GetITStatus||, CODE, READONLY, ALIGN=2

                  SDIO_GetITStatus PROC
;;;747      */
;;;748    ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
000000  4a03              LDR      r2,|L15.16|
;;;749    { 
000002  4601              MOV      r1,r0
;;;750      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;751      
;;;752      /* Check the parameters */
;;;753      assert_param(IS_SDIO_GET_IT(SDIO_IT));
;;;754      if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
000006  6b52              LDR      r2,[r2,#0x34]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L15.14|
;;;755      {
;;;756        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L15.14|
;;;757      }
;;;758      else
;;;759      {
;;;760        bitstatus = RESET;
;;;761      }
;;;762      return bitstatus;
;;;763    }
00000e  4770              BX       lr
;;;764    
                          ENDP

                  |L15.16|
                          DCD      0x40018000

                          AREA ||i.SDIO_GetPowerState||, CODE, READONLY, ALIGN=2

                  SDIO_GetPowerState PROC
;;;273      */
;;;274    uint32_t SDIO_GetPowerState(void)
000000  4802              LDR      r0,|L16.12|
;;;275    {
;;;276      return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
000002  6800              LDR      r0,[r0,#0]
000004  f0000003          AND      r0,r0,#3
;;;277    }
000008  4770              BX       lr
;;;278    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40018000

                          AREA ||i.SDIO_GetResponse||, CODE, READONLY, ALIGN=2

                  SDIO_GetResponse PROC
;;;416      */
;;;417    uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
000000  b508              PUSH     {r3,lr}
;;;418    {
;;;419      __IO uint32_t tmp = 0;
;;;420    
;;;421      /* Check the parameters */
;;;422      assert_param(IS_SDIO_RESP(SDIO_RESP));
;;;423    
;;;424      tmp = SDIO_RESP_ADDR + SDIO_RESP;
000002  4902              LDR      r1,|L17.12|
000004  4408              ADD      r0,r0,r1
;;;425      
;;;426      return (*(__IO uint32_t *) tmp); 
000006  9000              STR      r0,[sp,#0]
000008  6800              LDR      r0,[r0,#0]
;;;427    }
00000a  bd08              POP      {r3,pc}
;;;428    
                          ENDP

                  |L17.12|
                          DCD      0x40018014

                          AREA ||i.SDIO_ITConfig||, CODE, READONLY, ALIGN=2

                  SDIO_ITConfig PROC
;;;311      */
;;;312    void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L18.20|
;;;313    {
;;;314      /* Check the parameters */
;;;315      assert_param(IS_SDIO_IT(SDIO_IT));
;;;316      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;317      
;;;318      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;319      {
;;;320        /* Enable the SDIO interrupts */
;;;321        SDIO->MASK |= SDIO_IT;
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable the SDIO interrupts */
;;;326        SDIO->MASK &= ~SDIO_IT;
000004  6bd1              LDR      r1,[r2,#0x3c]
000006  d001              BEQ      |L18.12|
000008  4301              ORRS     r1,r1,r0              ;321
00000a  e000              B        |L18.14|
                  |L18.12|
00000c  4381              BICS     r1,r1,r0
                  |L18.14|
00000e  63d1              STR      r1,[r2,#0x3c]         ;321
;;;327      } 
;;;328    }
000010  4770              BX       lr
;;;329    
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x40018000

                          AREA ||i.SDIO_Init||, CODE, READONLY, ALIGN=2

                  SDIO_Init PROC
;;;186      */
;;;187    void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;188    {
;;;189      uint32_t tmpreg = 0;
;;;190        
;;;191      /* Check the parameters */
;;;192      assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
;;;193      assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
;;;194      assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
;;;195      assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
;;;196      assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
;;;197       
;;;198    /*---------------------------- SDIO CLKCR Configuration ------------------------*/  
;;;199      /* Get the SDIO CLKCR value */
;;;200      tmpreg = SDIO->CLKCR;
000002  4b09              LDR      r3,|L19.40|
000004  685a              LDR      r2,[r3,#4]
;;;201      
;;;202      /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
;;;203      tmpreg &= CLKCR_CLEAR_MASK;
000006  f64761ff          MOV      r1,#0x7eff
00000a  438a              BICS     r2,r2,r1
;;;204      
;;;205      /* Set CLKDIV bits according to SDIO_ClockDiv value */
;;;206      /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
;;;207      /* Set BYPASS bit according to SDIO_ClockBypass value */
;;;208      /* Set WIDBUS bits according to SDIO_BusWide value */
;;;209      /* Set NEGEDGE bits according to SDIO_ClockEdge value */
;;;210      /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
;;;211      tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
00000c  7d01              LDRB     r1,[r0,#0x14]
00000e  6884              LDR      r4,[r0,#8]
000010  68c5              LDR      r5,[r0,#0xc]
000012  4321              ORRS     r1,r1,r4
000014  6844              LDR      r4,[r0,#4]
000016  432c              ORRS     r4,r4,r5
000018  4321              ORRS     r1,r1,r4
00001a  6804              LDR      r4,[r0,#0]
00001c  6900              LDR      r0,[r0,#0x10]
00001e  4321              ORRS     r1,r1,r4
000020  4301              ORRS     r1,r1,r0
000022  4311              ORRS     r1,r1,r2
;;;212                 SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
;;;213                 SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
;;;214      
;;;215      /* Write to SDIO CLKCR */
;;;216      SDIO->CLKCR = tmpreg;
000024  6059              STR      r1,[r3,#4]
;;;217    }
000026  bd30              POP      {r4,r5,pc}
;;;218    
                          ENDP

                  |L19.40|
                          DCD      0x40018000

                          AREA ||i.SDIO_ReadData||, CODE, READONLY, ALIGN=2

                  SDIO_ReadData PROC
;;;502      */
;;;503    uint32_t SDIO_ReadData(void)
000000  4801              LDR      r0,|L20.8|
;;;504    { 
;;;505      return SDIO->FIFO;
000002  6800              LDR      r0,[r0,#0]
;;;506    }
000004  4770              BX       lr
;;;507    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x40018080

                          AREA ||i.SDIO_SendCEATACmd||, CODE, READONLY, ALIGN=2

                  SDIO_SendCEATACmd PROC
;;;631      */
;;;632    void SDIO_SendCEATACmd(FunctionalState NewState)
000000  4901              LDR      r1,|L21.8|
;;;633    { 
;;;634      /* Check the parameters */
;;;635      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;636      
;;;637      *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;638    }
000004  4770              BX       lr
;;;639    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x423001b8

                          AREA ||i.SDIO_SendCommand||, CODE, READONLY, ALIGN=2

                  SDIO_SendCommand PROC
;;;350      */
;;;351    void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
000000  b510              PUSH     {r4,lr}
;;;352    {
;;;353      uint32_t tmpreg = 0;
;;;354      
;;;355      /* Check the parameters */
;;;356      assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
;;;357      assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
;;;358      assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
;;;359      assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
;;;360      
;;;361    /*---------------------------- SDIO ARG Configuration ------------------------*/
;;;362      /* Set the SDIO Argument value */
;;;363      SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
000002  4a08              LDR      r2,|L22.36|
000004  6801              LDR      r1,[r0,#0]
000006  6091              STR      r1,[r2,#8]
;;;364      
;;;365    /*---------------------------- SDIO CMD Configuration ------------------------*/  
;;;366      /* Get the SDIO CMD value */
;;;367      tmpreg = SDIO->CMD;
000008  68d1              LDR      r1,[r2,#0xc]
;;;368      /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
;;;369      tmpreg &= CMD_CLEAR_MASK;
00000a  0acb              LSRS     r3,r1,#11
00000c  e9d01401          LDRD     r1,r4,[r0,#4]
;;;370      /* Set CMDINDEX bits according to SDIO_CmdIndex value */
;;;371      /* Set WAITRESP bits according to SDIO_Response value */
;;;372      /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
;;;373      /* Set CPSMEN bits according to SDIO_CPSM value */
;;;374      tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
000010  4321              ORRS     r1,r1,r4
000012  e9d04003          LDRD     r4,r0,[r0,#0xc]
000016  4304              ORRS     r4,r4,r0
000018  02db              LSLS     r3,r3,#11             ;369
00001a  4321              ORRS     r1,r1,r4
00001c  4319              ORRS     r1,r1,r3
;;;375               | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
;;;376      
;;;377      /* Write to SDIO CMD */
;;;378      SDIO->CMD = tmpreg;
00001e  60d1              STR      r1,[r2,#0xc]
;;;379    }
000020  bd10              POP      {r4,pc}
;;;380    
                          ENDP

000022  0000              DCW      0x0000
                  |L22.36|
                          DCD      0x40018000

                          AREA ||i.SDIO_SendSDIOSuspendCmd||, CODE, READONLY, ALIGN=2

                  SDIO_SendSDIOSuspendCmd PROC
;;;591      */
;;;592    void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L23.8|
;;;593    { 
;;;594      /* Check the parameters */
;;;595      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;596      
;;;597      *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;598    }
000004  4770              BX       lr
;;;599    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x423001ac

                          AREA ||i.SDIO_SetPowerState||, CODE, READONLY, ALIGN=2

                  SDIO_SetPowerState PROC
;;;256      */
;;;257    void SDIO_SetPowerState(uint32_t SDIO_PowerState)
000000  4901              LDR      r1,|L24.8|
;;;258    {
;;;259      /* Check the parameters */
;;;260      assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
;;;261      
;;;262      SDIO->POWER = SDIO_PowerState;
000002  6008              STR      r0,[r1,#0]
;;;263    }
000004  4770              BX       lr
;;;264    
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      0x40018000

                          AREA ||i.SDIO_SetSDIOOperation||, CODE, READONLY, ALIGN=2

                  SDIO_SetSDIOOperation PROC
;;;577      */
;;;578    void SDIO_SetSDIOOperation(FunctionalState NewState)
000000  4901              LDR      r1,|L25.8|
;;;579    { 
;;;580      /* Check the parameters */
;;;581      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;582      
;;;583      *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;584    }
000004  4770              BX       lr
;;;585    
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x423005ac

                          AREA ||i.SDIO_SetSDIOReadWaitMode||, CODE, READONLY, ALIGN=2

                  SDIO_SetSDIOReadWaitMode PROC
;;;563      */
;;;564    void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
000000  4901              LDR      r1,|L26.8|
;;;565    {
;;;566      /* Check the parameters */
;;;567      assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
;;;568      
;;;569      *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
000002  6008              STR      r0,[r1,#0]
;;;570    }
000004  4770              BX       lr
;;;571    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x423005a8

                          AREA ||i.SDIO_StartSDIOReadWait||, CODE, READONLY, ALIGN=2

                  SDIO_StartSDIOReadWait PROC
;;;533      */
;;;534    void SDIO_StartSDIOReadWait(FunctionalState NewState)
000000  4901              LDR      r1,|L27.8|
;;;535    { 
;;;536      /* Check the parameters */
;;;537      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;538      
;;;539      *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;540    }
000004  4770              BX       lr
;;;541    
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x423005a0

                          AREA ||i.SDIO_StopSDIOReadWait||, CODE, READONLY, ALIGN=2

                  SDIO_StopSDIOReadWait PROC
;;;547      */
;;;548    void SDIO_StopSDIOReadWait(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;549    { 
;;;550      /* Check the parameters */
;;;551      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;552      
;;;553      *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;554    }
000004  4770              BX       lr
;;;555    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x423005a4

                          AREA ||i.SDIO_StructInit||, CODE, READONLY, ALIGN=1

                  SDIO_StructInit PROC
;;;224      */
;;;225    void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
000000  2100              MOVS     r1,#0
;;;226    {
;;;227      /* SDIO_InitStruct members default value */
;;;228      SDIO_InitStruct->SDIO_ClockDiv = 0x00;
000002  7501              STRB     r1,[r0,#0x14]
;;;229      SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
;;;230      SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
000004  6001              STR      r1,[r0,#0]
;;;231      SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
000006  6041              STR      r1,[r0,#4]
;;;232      SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
000008  6081              STR      r1,[r0,#8]
;;;233      SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
00000a  60c1              STR      r1,[r0,#0xc]
00000c  6101              STR      r1,[r0,#0x10]
;;;234    }
00000e  4770              BX       lr
;;;235    
                          ENDP


                          AREA ||i.SDIO_WriteData||, CODE, READONLY, ALIGN=2

                  SDIO_WriteData PROC
;;;512      */
;;;513    void SDIO_WriteData(uint32_t Data)
000000  4901              LDR      r1,|L30.8|
;;;514    { 
;;;515      SDIO->FIFO = Data;
000002  6008              STR      r0,[r1,#0]
;;;516    }
000004  4770              BX       lr
;;;517    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      0x40018080

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_sdio.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f10x_sdio_c_c8827541____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f10x_sdio_c_c8827541____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f10x_sdio_c_c8827541____REVSH|
#line 144
|__asm___16_stm32f10x_sdio_c_c8827541____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
