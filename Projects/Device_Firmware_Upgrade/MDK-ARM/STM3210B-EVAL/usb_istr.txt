; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\usb_istr.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\DFU\inc -I..\..\..\Utilities\STM32_EVAL\Common -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL --omf_browse=.\stm3210b-eval\usb_istr.crf ..\src\usb_istr.c]
                          THUMB

                          AREA ||i.USB_Istr||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;76     *******************************************************************************/
;;;77     void USB_Istr(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;78     {
;;;79         uint32_t i=0;
;;;80      __IO uint32_t EP[8];
;;;81       
;;;82       wIstr = _GetISTR();
000004  4e4a              LDR      r6,|L1.304|
000006  b088              SUB      sp,sp,#0x20           ;78
000008  2400              MOVS     r4,#0                 ;79
00000a  6830              LDR      r0,[r6,#0]
00000c  4d49              LDR      r5,|L1.308|
00000e  8068              STRH     r0,[r5,#2]
;;;83     
;;;84     #if (IMR_MSK & ISTR_CTR)
;;;85       if (wIstr & ISTR_CTR & wInterrupt_Mask)
000010  8868              LDRH     r0,[r5,#2]  ; wIstr
000012  4f49              LDR      r7,|L1.312|
000014  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
000016  4008              ANDS     r0,r0,r1
000018  0400              LSLS     r0,r0,#16
00001a  d501              BPL      |L1.32|
;;;86       {
;;;87         /* servicing of the endpoint correct transfer interrupt */
;;;88         /* clear of the CTR flag into the sub */
;;;89         CTR_LP();
00001c  f7fffffe          BL       CTR_LP
                  |L1.32|
;;;90     #ifdef CTR_CALLBACK
;;;91         CTR_Callback();
;;;92     #endif
;;;93       }
;;;94     #endif
;;;95       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/  
;;;96     #if (IMR_MSK & ISTR_RESET)
;;;97       if (wIstr & ISTR_RESET & wInterrupt_Mask)
000020  8868              LDRH     r0,[r5,#2]  ; wIstr
000022  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
;;;98       {
;;;99         _SetISTR((uint16_t)CLR_RESET);
000024  f64f38ff          MOV      r8,#0xfbff
000028  4008              ANDS     r0,r0,r1              ;97
00002a  0540              LSLS     r0,r0,#21             ;97
00002c  d504              BPL      |L1.56|
00002e  f8c68000          STR      r8,[r6,#0]
;;;100        Device_Property.Reset();
000032  4842              LDR      r0,|L1.316|
000034  6840              LDR      r0,[r0,#4]  ; Device_Property
000036  4780              BLX      r0
                  |L1.56|
;;;101    #ifdef RESET_CALLBACK
;;;102        RESET_Callback();
;;;103    #endif
;;;104      }
;;;105    #endif
;;;106      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;107    #if (IMR_MSK & ISTR_DOVR)
;;;108      if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;109      {
;;;110        _SetISTR((uint16_t)CLR_DOVR);
;;;111    #ifdef DOVR_CALLBACK
;;;112        DOVR_Callback();
;;;113    #endif
;;;114      }
;;;115    #endif
;;;116      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;117    #if (IMR_MSK & ISTR_ERR)
;;;118      if (wIstr & ISTR_ERR & wInterrupt_Mask)
000038  8869              LDRH     r1,[r5,#2]  ; wIstr
00003a  8838              LDRH     r0,[r7,#0]  ; wInterrupt_Mask
00003c  4001              ANDS     r1,r1,r0
00003e  0489              LSLS     r1,r1,#18
000040  d502              BPL      |L1.72|
;;;119      {
;;;120        _SetISTR((uint16_t)CLR_ERR);
000042  f64d71ff          MOV      r1,#0xdfff
000046  6031              STR      r1,[r6,#0]
                  |L1.72|
;;;121    #ifdef ERR_CALLBACK
;;;122        ERR_Callback();
;;;123    #endif
;;;124      }
;;;125    #endif
;;;126      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;127    #if (IMR_MSK & ISTR_WKUP)
;;;128      if (wIstr & ISTR_WKUP & wInterrupt_Mask)
000048  8869              LDRH     r1,[r5,#2]  ; wIstr
00004a  4001              ANDS     r1,r1,r0
00004c  04c8              LSLS     r0,r1,#19
00004e  d505              BPL      |L1.92|
;;;129      {
;;;130        _SetISTR((uint16_t)CLR_WKUP);
000050  f64e70ff          MOV      r0,#0xefff
000054  6030              STR      r0,[r6,#0]
;;;131        Resume(RESUME_EXTERNAL);
000056  2000              MOVS     r0,#0
000058  f7fffffe          BL       Resume
                  |L1.92|
;;;132    #ifdef WKUP_CALLBACK
;;;133        WKUP_Callback();
;;;134    #endif
;;;135      }
;;;136    #endif
;;;137      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;138    #if (IMR_MSK & ISTR_SUSP)
;;;139      if (wIstr & ISTR_SUSP & wInterrupt_Mask)
00005c  8868              LDRH     r0,[r5,#2]  ; wIstr
00005e  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
000060  4008              ANDS     r0,r0,r1
000062  0500              LSLS     r0,r0,#20
000064  d50b              BPL      |L1.126|
;;;140      {
;;;141    
;;;142        /* check if SUSPEND is possible */
;;;143        if (fSuspendEnabled)
000066  4836              LDR      r0,|L1.320|
000068  7800              LDRB     r0,[r0,#0]  ; fSuspendEnabled
00006a  b110              CBZ      r0,|L1.114|
;;;144        {
;;;145          Suspend();
00006c  f7fffffe          BL       Suspend
000070  e002              B        |L1.120|
                  |L1.114|
;;;146        }
;;;147        else
;;;148        {
;;;149          /* if not possible then resume after xx ms */
;;;150          Resume(RESUME_LATER);
000072  2002              MOVS     r0,#2
000074  f7fffffe          BL       Resume
                  |L1.120|
;;;151        }
;;;152        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;153        _SetISTR((uint16_t)CLR_SUSP);
000078  f24f70ff          MOV      r0,#0xf7ff
00007c  6030              STR      r0,[r6,#0]
                  |L1.126|
;;;154    #ifdef SUSP_CALLBACK
;;;155        SUSP_Callback();
;;;156    #endif
;;;157      }
;;;158    #endif
;;;159      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;160    #if (IMR_MSK & ISTR_SOF)
;;;161      if (wIstr & ISTR_SOF & wInterrupt_Mask)
00007e  8869              LDRH     r1,[r5,#2]  ; wIstr
000080  8838              LDRH     r0,[r7,#0]  ; wInterrupt_Mask
000082  4001              ANDS     r1,r1,r0
000084  0589              LSLS     r1,r1,#22
000086  d506              BPL      |L1.150|
;;;162      {
;;;163        _SetISTR((uint16_t)CLR_SOF);
000088  f64f51ff          MOV      r1,#0xfdff
00008c  6031              STR      r1,[r6,#0]
;;;164        bIntPackSOF++;
00008e  7829              LDRB     r1,[r5,#0]  ; bIntPackSOF
000090  f1010101          ADD      r1,r1,#1
000094  7029              STRB     r1,[r5,#0]
                  |L1.150|
;;;165    
;;;166    #ifdef SOF_CALLBACK
;;;167        SOF_Callback();
;;;168    #endif
;;;169      }
;;;170    #endif
;;;171      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;172    #if (IMR_MSK & ISTR_ESOF)
;;;173      if (wIstr & ISTR_ESOF & wInterrupt_Mask)
000096  8869              LDRH     r1,[r5,#2]  ; wIstr
000098  ea010100          AND      r1,r1,r0
00009c  05c8              LSLS     r0,r1,#23
00009e  d543              BPL      |L1.296|
;;;174      {
;;;175        /* clear ESOF flag in ISTR */
;;;176        _SetISTR((uint16_t)CLR_ESOF);
0000a0  f64f60ff          MOV      r0,#0xfeff
0000a4  6030              STR      r0,[r6,#0]
;;;177        
;;;178        if ((_GetFNR()&FNR_RXDP)!=0)
0000a6  4822              LDR      r0,|L1.304|
0000a8  1d00              ADDS     r0,r0,#4
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f04f0200          MOV      r2,#0
0000b0  0400              LSLS     r0,r0,#16
0000b2  d535              BPL      |L1.288|
;;;179        {
;;;180          /* increment ESOF counter */
;;;181          esof_counter ++;
0000b4  6868              LDR      r0,[r5,#4]  ; esof_counter
0000b6  1c40              ADDS     r0,r0,#1
0000b8  6068              STR      r0,[r5,#4]  ; esof_counter
;;;182          
;;;183          /* test if we enter in ESOF more than 3 times with FSUSP =0 and RXDP =1=>> possible missing SUSP flag*/
;;;184          if ((esof_counter >3)&&((_GetCNTR()&CNTR_FSUSP)==0))
0000ba  6868              LDR      r0,[r5,#4]  ; esof_counter
0000bc  2803              CMP      r0,#3
0000be  d930              BLS      |L1.290|
0000c0  481b              LDR      r0,|L1.304|
0000c2  1f00              SUBS     r0,r0,#4
0000c4  6801              LDR      r1,[r0,#0]
0000c6  0709              LSLS     r1,r1,#28
0000c8  d42b              BMI      |L1.290|
;;;185          {           
;;;186            /* this a sequence to apply a force RESET*/
;;;187          
;;;188            /*Store CNTR value */
;;;189            wCNTR = _GetCNTR(); 
0000ca  6801              LDR      r1,[r0,#0]
0000cc  b289              UXTH     r1,r1
0000ce  60a9              STR      r1,[r5,#8]  ; wCNTR
;;;190          
;;;191            /*Store endpoints registers status */
;;;192            for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
0000d0  4917              LDR      r1,|L1.304|
0000d2  ea4f030d          MOV.W    r3,sp
0000d6  3944              SUBS     r1,r1,#0x44
                  |L1.216|
0000d8  f8517024          LDR      r7,[r1,r4,LSL #2]
0000dc  b2bf              UXTH     r7,r7
0000de  f8437024          STR      r7,[r3,r4,LSL #2]
0000e2  1c64              ADDS     r4,r4,#1
0000e4  2c08              CMP      r4,#8
0000e6  d3f7              BCC      |L1.216|
;;;193          
;;;194            /*apply FRES */
;;;195            wCNTR|=CNTR_FRES;
0000e8  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000ea  f0440401          ORR      r4,r4,#1
0000ee  60ac              STR      r4,[r5,#8]  ; wCNTR
;;;196            _SetCNTR(wCNTR);
0000f0  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000f2  b2a4              UXTH     r4,r4
0000f4  6004              STR      r4,[r0,#0]
;;;197     
;;;198            /*clear FRES*/
;;;199            wCNTR&=~CNTR_FRES;
0000f6  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000f8  f0240401          BIC      r4,r4,#1
0000fc  60ac              STR      r4,[r5,#8]  ; wCNTR
;;;200            _SetCNTR(wCNTR);
0000fe  68ac              LDR      r4,[r5,#8]  ; wCNTR
000100  b2a4              UXTH     r4,r4
000102  6004              STR      r4,[r0,#0]
                  |L1.260|
;;;201          
;;;202            /*poll for RESET flag in ISTR*/
;;;203            while((_GetISTR()&ISTR_RESET) == 0);
000104  6830              LDR      r0,[r6,#0]
000106  0540              LSLS     r0,r0,#21
000108  d5fc              BPL      |L1.260|
;;;204      
;;;205            /* clear RESET flag in ISTR */
;;;206            _SetISTR((uint16_t)CLR_RESET);
00010a  f8c68000          STR      r8,[r6,#0]
;;;207       
;;;208           /*restore Enpoints*/
;;;209            for (i=0;i<8;i++)
00010e  2000              MOVS     r0,#0
                  |L1.272|
;;;210            _SetENDPOINT(i, EP[i]);
000110  f8534020          LDR      r4,[r3,r0,LSL #2]
000114  b2a4              UXTH     r4,r4
000116  f8414020          STR      r4,[r1,r0,LSL #2]
00011a  1c40              ADDS     r0,r0,#1              ;209
00011c  2808              CMP      r0,#8                 ;209
00011e  d3f7              BCC      |L1.272|
                  |L1.288|
;;;211          
;;;212            esof_counter = 0;
000120  606a              STR      r2,[r5,#4]  ; esof_counter
                  |L1.290|
;;;213          }
;;;214        }
;;;215        else
;;;216        {
;;;217            esof_counter = 0;
;;;218        }
;;;219        
;;;220        /* resume handling timing is made with ESOFs */
;;;221        Resume(RESUME_ESOF); /* request without change of the machine state */
000122  2007              MOVS     r0,#7
000124  f7fffffe          BL       Resume
                  |L1.296|
;;;222    
;;;223    #ifdef ESOF_CALLBACK
;;;224        ESOF_Callback();
;;;225    #endif
;;;226      }
;;;227    #endif
;;;228    } /* USB_Istr */
000128  b008              ADD      sp,sp,#0x20
00012a  e8bd81f0          POP      {r4-r8,pc}
;;;229    
                          ENDP

00012e  0000              DCW      0x0000
                  |L1.304|
                          DCD      0x40005c44
                  |L1.308|
                          DCD      ||.data||
                  |L1.312|
                          DCD      wInterrupt_Mask
                  |L1.316|
                          DCD      Device_Property
                  |L1.320|
                          DCD      fSuspendEnabled

                          AREA ||.data||, DATA, ALIGN=2

                  bIntPackSOF
000000  0000              DCB      0x00,0x00
                  wIstr
000002  0000              DCB      0x00,0x00
                  esof_counter
                          DCD      0x00000000
                  wCNTR
                          DCD      0x00000000

                          AREA ||area_number.5||, DATA, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.data||
                  pEpInt_IN
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

                          AREA ||area_number.6||, DATA, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.data||
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_istr.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_istr_c_e9471872____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REVSH|
#line 144
|__asm___10_usb_istr_c_e9471872____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
