; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\stmflash.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\stmflash.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\DFU\inc -I..\..\..\Utilities\STM32_EVAL\Common -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL --omf_browse=.\stm3210b-eval\stmflash.crf ..\DFU\src\stmflash.c]
                          THUMB

                          AREA ||i.STMFLASH_Read||, CODE, READONLY, ALIGN=2

                  STMFLASH_Read PROC
;;;97       */
;;;98     void STMFLASH_Read(u32 ReadAddr,u16 *pBuffer,u16 NumToRead)   	
000000  b510              PUSH     {r4,lr}
;;;99     {
;;;100    	u16 i;
;;;101    	for(i=0;i<NumToRead;i++)
000002  2300              MOVS     r3,#0
000004  e006              B        |L1.20|
000006  bf00              NOP                            ;99
                  |L1.8|
000008  f8304b02          LDRH     r4,[r0],#2            ;99
;;;102    	{
;;;103    		pBuffer[i]=STMFLASH_ReadHalfWord(ReadAddr);//读取2个字节.
00000c  f8214013          STRH     r4,[r1,r3,LSL #1]
000010  1c5b              ADDS     r3,r3,#1              ;101
000012  b29b              UXTH     r3,r3                 ;101
                  |L1.20|
000014  4293              CMP      r3,r2                 ;101
000016  d3f7              BCC      |L1.8|
;;;104    		ReadAddr+=2;//偏移2个字节.	
;;;105    	}
;;;106    }
000018  bd10              POP      {r4,pc}
;;;107    
                          ENDP


                          AREA ||i.STMFLASH_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  STMFLASH_ReadHalfWord PROC
;;;8        */
;;;9      u16 STMFLASH_ReadHalfWord(u32 faddr)
000000  8800              LDRH     r0,[r0,#0]
;;;10     {
;;;11     	return *(vu16*)faddr; 
;;;12     }
000002  4770              BX       lr
;;;13     
                          ENDP


                          AREA ||i.STMFLASH_Write||, CODE, READONLY, ALIGN=2

                  STMFLASH_Write PROC
;;;42       */
;;;43     void STMFLASH_Write(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite)	
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;44     {
;;;45     	u32 secpos;	   //扇区地址
;;;46     	u16 secoff;	   //扇区内偏移地址(16位字计算)
;;;47     	u16 secremain; //扇区内剩余地址(16位字计算)	   
;;;48      	u16 i;    
;;;49     	u32 offaddr;   //去掉0X08000000后的地址
;;;50     	if((WriteAddr < FLASH_BASE) || (WriteAddr >= FLASH_BASE + 1024 * FLASH_SIZE))return;//非法地址
000004  f1a06400          SUB      r4,r0,#0x8000000
000008  f04f6800          MOV      r8,#0x8000000
00000c  4615              MOV      r5,r2                 ;44
00000e  468a              MOV      r10,r1                ;44
000010  4683              MOV      r11,r0                ;44
000012  4544              CMP      r4,r8
000014  d253              BCS      |L3.190|
;;;51     	FLASH_Unlock();						//解锁
000016  f7fffffe          BL       FLASH_Unlock
;;;52     	offaddr = WriteAddr - FLASH_BASE;		//实际偏移地址.
;;;53     	secpos = offaddr / PAGE_SIZE;			//扇区地址  0~127 for STM32F103RBT6
00001a  0aa7              LSRS     r7,r4,#10
;;;54     	secoff = (offaddr % PAGE_SIZE) / 2;		//在扇区内的偏移(2个字节为基本单位.)
00001c  f3c40648          UBFX     r6,r4,#1,#9
;;;55     	secremain = PAGE_SIZE / 2 - secoff;		//扇区剩余空间大小   
000020  f5c67400          RSB      r4,r6,#0x200
;;;56     	if(NumToWrite <= secremain)
000024  42a5              CMP      r5,r4
000026  d800              BHI      |L3.42|
;;;57     		secremain = NumToWrite;//不大于该扇区范围
000028  462c              MOV      r4,r5
                  |L3.42|
;;;58     	while(1) 
;;;59     	{	
;;;60     		STMFLASH_Read(secpos * PAGE_SIZE + FLASH_BASE, STMFLASH_BUF, PAGE_SIZE / 2);//读出整个扇区的内容
00002a  f8df9098          LDR      r9,|L3.196|
00002e  bf00              NOP      
                  |L3.48|
000030  f04f6000          MOV      r0,#0x8000000
000034  eb002087          ADD      r0,r0,r7,LSL #10
000038  4680              MOV      r8,r0
00003a  f44f7200          MOV      r2,#0x200
00003e  4921              LDR      r1,|L3.196|
000040  f7fffffe          BL       STMFLASH_Read
;;;61     		for(i = 0; i < secremain; i++)//校验数据
000044  2000              MOVS     r0,#0
;;;62     		{
;;;63     			if(STMFLASH_BUF[secoff + i] != 0XFFFF)break;//需要擦除  	  
000046  f64f71ff          MOV      r1,#0xffff
00004a  e006              B        |L3.90|
                  |L3.76|
00004c  1833              ADDS     r3,r6,r0
00004e  f8392013          LDRH     r2,[r9,r3,LSL #1]
000052  428a              CMP      r2,r1
000054  d103              BNE      |L3.94|
000056  1c40              ADDS     r0,r0,#1              ;61
000058  b280              UXTH     r0,r0                 ;61
                  |L3.90|
00005a  42a0              CMP      r0,r4                 ;61
00005c  d3f6              BCC      |L3.76|
                  |L3.94|
;;;64     		}
;;;65     		if(i < secremain)//需要擦除
00005e  42a0              CMP      r0,r4
000060  d225              BCS      |L3.174|
000062  4640              MOV      r0,r8
;;;66     		{
;;;67     			FLASH_ErasePage(secpos * PAGE_SIZE + FLASH_BASE);//擦除这个扇区
000064  f7fffffe          BL       FLASH_ErasePage
;;;68     			for(i=0; i < secremain; i++)
000068  2000              MOVS     r0,#0
00006a  4649              MOV      r1,r9                 ;60
00006c  e007              B        |L3.126|
;;;69     			{
;;;70     				STMFLASH_BUF[i + secoff] = pBuffer[i];	  
00006e  bf00              NOP      
                  |L3.112|
000070  f83a2010          LDRH     r2,[r10,r0,LSL #1]
000074  1983              ADDS     r3,r0,r6
000076  1c40              ADDS     r0,r0,#1              ;68
000078  f8212013          STRH     r2,[r1,r3,LSL #1]
00007c  b280              UXTH     r0,r0                 ;68
                  |L3.126|
00007e  42a0              CMP      r0,r4                 ;68
000080  d3f6              BCC      |L3.112|
;;;71     			}
;;;72     			STMFLASH_Write_NoCheck(secpos * PAGE_SIZE + FLASH_BASE, STMFLASH_BUF, PAGE_SIZE / 2);//写入整个扇区  
000082  4910              LDR      r1,|L3.196|
000084  4640              MOV      r0,r8                 ;68
000086  f44f7200          MOV      r2,#0x200
;;;73     		}else 
;;;74     			STMFLASH_Write_NoCheck(WriteAddr, pBuffer, secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
00008a  bf00              NOP      
                  |L3.140|
00008c  f7fffffe          BL       STMFLASH_Write_NoCheck
;;;75     		if(NumToWrite == secremain)break;//写入结束了
000090  42a5              CMP      r5,r4
000092  d010              BEQ      |L3.182|
;;;76     		else//写入未结束
;;;77     		{
;;;78     			secpos++;				//扇区地址增1
;;;79     			secoff = 0;				//偏移位置为0 	 
;;;80     		   	pBuffer += secremain;  	//指针偏移
;;;81     			WriteAddr += secremain;	//写地址偏移	   
;;;82     		   	NumToWrite -= secremain;	//字节(16位)数递减
000094  1b28              SUBS     r0,r5,r4
000096  eb0a0a44          ADD      r10,r10,r4,LSL #1     ;80
00009a  44a3              ADD      r11,r11,r4            ;81
00009c  1c7f              ADDS     r7,r7,#1              ;78
00009e  2600              MOVS     r6,#0                 ;79
0000a0  b285              UXTH     r5,r0
;;;83     			if(NumToWrite > (PAGE_SIZE / 2)) secremain = PAGE_SIZE / 2;//下一个扇区还是写不完
0000a2  f44f7400          MOV      r4,#0x200
0000a6  42a5              CMP      r5,r4
0000a8  d8c2              BHI      |L3.48|
;;;84     			else secremain = NumToWrite;//下一个扇区可以写完了
0000aa  462c              MOV      r4,r5
0000ac  e7c0              B        |L3.48|
                  |L3.174|
0000ae  4622              MOV      r2,r4                 ;74
0000b0  4651              MOV      r1,r10                ;74
0000b2  4658              MOV      r0,r11                ;74
0000b4  e7ea              B        |L3.140|
                  |L3.182|
;;;85     		}	 
;;;86     	};	
;;;87     	FLASH_Lock();//上锁
0000b6  e8bd5ff0          POP      {r4-r12,lr}
0000ba  f7ffbffe          B.W      FLASH_Lock
                  |L3.190|
;;;88     }
0000be  e8bd9ff0          POP      {r4-r12,pc}
;;;89     
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      ||.bss||

                          AREA ||i.STMFLASH_Write_NoCheck||, CODE, READONLY, ALIGN=2

                  STMFLASH_Write_NoCheck PROC
;;;22       */
;;;23     static void STMFLASH_Write_NoCheck(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;24     { 			 		 
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;25     	u16 i;
;;;26     	for(i=0;i<NumToWrite;i++)
00000a  2400              MOVS     r4,#0
00000c  e008              B        |L4.32|
;;;27     	{
;;;28     		FLASH_ProgramHalfWord(WriteAddr,pBuffer[i]);
00000e  bf00              NOP      
                  |L4.16|
000010  f8371014          LDRH     r1,[r7,r4,LSL #1]
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       FLASH_ProgramHalfWord
;;;29     	    WriteAddr+=2;//add addr 2.
00001a  1cad              ADDS     r5,r5,#2
00001c  1c64              ADDS     r4,r4,#1              ;26
00001e  b2a4              UXTH     r4,r4                 ;26
                  |L4.32|
000020  42b4              CMP      r4,r6                 ;26
000022  d3f5              BCC      |L4.16|
;;;30     	}  
;;;31     } 
000024  e8bd81f0          POP      {r4-r8,pc}
;;;32     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  STMFLASH_BUF
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\DFU\\src\\stmflash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_stmflash_c_69bb3012____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_stmflash_c_69bb3012____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_stmflash_c_69bb3012____REVSH|
#line 144
|__asm___10_stmflash_c_69bb3012____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
