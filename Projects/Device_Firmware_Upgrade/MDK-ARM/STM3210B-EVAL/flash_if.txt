; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\flash_if.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\flash_if.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\DFU\inc -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL ..\src\flash_if.c]
                          THUMB

                          AREA ||i.FLASH_If_Erase||, CODE, READONLY, ALIGN=1

                  FLASH_If_Erase PROC
;;;64     *******************************************************************************/
;;;65     uint16_t FLASH_If_Erase(uint32_t SectorAddress)
000000  b510              PUSH     {r4,lr}
;;;66     {
;;;67     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;68       FLASH_ClearFlag(FLASH_FLAG_PGAERR | FLASH_FLAG_OPTVERR);
;;;69       FLASH_ErasePage(SectorAddress);
;;;70     #else
;;;71       FLASH_ErasePage(SectorAddress);
000002  f7fffffe          BL       FLASH_ErasePage
;;;72     #endif /* STM32L1XX_XD */
;;;73       
;;;74       return MAL_OK;
000006  2000              MOVS     r0,#0
;;;75     }
000008  bd10              POP      {r4,pc}
;;;76     
                          ENDP


                          AREA ||i.FLASH_If_Init||, CODE, READONLY, ALIGN=1

                  FLASH_If_Init PROC
;;;52     *******************************************************************************/
;;;53     uint16_t FLASH_If_Init(void)
000000  2000              MOVS     r0,#0
;;;54     {
;;;55       return MAL_OK;
;;;56     }
000002  4770              BX       lr
;;;57     
                          ENDP


                          AREA ||i.FLASH_If_Read||, CODE, READONLY, ALIGN=1

                  FLASH_If_Read PROC
;;;165    *******************************************************************************/
;;;166    uint8_t *FLASH_If_Read (uint32_t SectorAddress, uint32_t DataLength)
000000  4770              BX       lr
;;;167    {
;;;168      return  (uint8_t*)(SectorAddress);
;;;169    }
;;;170    
                          ENDP


                          AREA ||i.FLASH_If_Write||, CODE, READONLY, ALIGN=2

                  FLASH_If_Write PROC
;;;83     *******************************************************************************/
;;;84     uint16_t FLASH_If_Write(uint32_t SectorAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;85     {
000004  4606              MOV      r6,r0
;;;86       uint32_t idx = 0;
;;;87     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;88       __IO uint32_t* malPointer = (uint32_t *)MAL_Buffer;
;;;89       __IO uint32_t* memPointer = (uint32_t *)SectorAddress;
;;;90       __IO uint32_t memBuffer[32]; /* Temporary buffer holding data that will be written in a half-page space */
;;;91       __IO uint32_t* mempBuffer = memBuffer;  
;;;92       __IO uint32_t* tmp;
;;;93     #endif /* STM32L1XX_XD */      
;;;94       
;;;95       if  (DataLength & 0x3) /* Not an aligned data */
;;;96       {
;;;97         for (idx = DataLength; idx < ((DataLength & 0xFFFC) + 4); idx++)
;;;98         {
;;;99           MAL_Buffer[idx] = 0xFF;
000006  4d0e              LDR      r5,|L4.64|
000008  460f              MOV      r7,r1                 ;85
00000a  0788              LSLS     r0,r1,#30             ;95
00000c  d00b              BEQ      |L4.38|
00000e  460c              MOV      r4,r1                 ;97
000010  f64f72fc          MOV      r2,#0xfffc            ;97
000014  20ff              MOVS     r0,#0xff
000016  ea070102          AND      r1,r7,r2              ;97
00001a  1d09              ADDS     r1,r1,#4              ;97
00001c  e001              B        |L4.34|
                  |L4.30|
00001e  5528              STRB     r0,[r5,r4]
000020  1c64              ADDS     r4,r4,#1              ;97
                  |L4.34|
000022  42a1              CMP      r1,r4                 ;97
000024  d8fb              BHI      |L4.30|
                  |L4.38|
;;;100        }
;;;101      } 
;;;102      
;;;103    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) 
;;;104      /* Reinitialize the intermediate buffer pointer */
;;;105      mempBuffer = memBuffer;
;;;106      
;;;107      /* If the address is not aligned to half-page fill the first location with existing data */
;;;108      if (((uint32_t)memPointer & 0x7F) != 0)
;;;109      {
;;;110        /* get the aligned address */
;;;111        tmp = (uint32_t *)((uint32_t)memPointer & 0xFFFFFF80);
;;;112        
;;;113        /* Read the first part from the memory */
;;;114        while (tmp < memPointer)
;;;115        {
;;;116          *(uint32_t *)(mempBuffer++) = *(uint32_t *)(tmp++);
;;;117        }
;;;118      }    
;;;119      
;;;120      while (malPointer < (uint32_t*)(MAL_Buffer + DataLength))
;;;121      {    
;;;122        /* Fill with the received buffer */
;;;123        while (mempBuffer < (memBuffer + 32))
;;;124        {
;;;125          /* If there are still data available in the received buffer */
;;;126          if (malPointer < ((uint32_t *)MAL_Buffer + DataLength))
;;;127          {
;;;128            *(uint32_t *)(mempBuffer++) = *(uint32_t *)(malPointer++);
;;;129          }
;;;130          else /* no more data available in the received buffer: fill remaining with dummy 0 */
;;;131          {
;;;132            *(uint32_t *)(mempBuffer++) = 0;
;;;133          }
;;;134        }
;;;135       
;;;136        /* Write the buffer to the memory*/    
;;;137        FLASH_ProgramHalfPage(((uint32_t)memPointer & 0xFFFFFF80), (uint32_t *)(memBuffer));    
;;;138        
;;;139        /* Increment the memory pointer */ 
;;;140        memPointer = (uint32_t *)(((uint32_t)memPointer & 0xFFFFFF80) + (32*4));
;;;141        
;;;142        /* Reinitialize the intermediate buffer pointer */
;;;143        mempBuffer = memBuffer;
;;;144      }
;;;145      
;;;146    #else
;;;147      
;;;148      /* Data received are Word multiple */    
;;;149      for (idx = 0; idx <  DataLength; idx = idx + 4)
000026  2400              MOVS     r4,#0
000028  e005              B        |L4.54|
                  |L4.42|
;;;150      {
;;;151        FLASH_ProgramWord(SectorAddress, *(uint32_t *)(MAL_Buffer + idx));  
00002a  5929              LDR      r1,[r5,r4]
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       FLASH_ProgramWord
;;;152        SectorAddress += 4;
000032  1d36              ADDS     r6,r6,#4
000034  1d24              ADDS     r4,r4,#4              ;149
                  |L4.54|
000036  42bc              CMP      r4,r7                 ;149
000038  d3f7              BCC      |L4.42|
;;;153      } 
;;;154    #endif /* STM32L1XX_XD */
;;;155     
;;;156      return MAL_OK;
00003a  2000              MOVS     r0,#0
;;;157    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;158    
                          ENDP

                  |L4.64|
                          DCD      MAL_Buffer

;*** Start embedded assembler ***

#line 1 "..\\src\\flash_if.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_flash_if_c_79a35935____REV16|
#line 129 "D:\\Keil5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_flash_if_c_79a35935____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_flash_if_c_79a35935____REVSH|
#line 144
|__asm___10_flash_if_c_79a35935____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
